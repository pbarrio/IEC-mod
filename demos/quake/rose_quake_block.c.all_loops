/* Adapted from
 * Quake benchmark
 * Loukas Kallivokas and David O'Hallaron
 * Carnegie Mellon University, November, 1997
 */
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "ie.h"
#define AMAX_NAME  128
#ifndef PI
#  define PI 3.141592653589793238
#endif

struct options
{
	/* run quietly unless there are errors (-Q) */
	int quiet;
	/* do we want to print a help message (-h -H) */
	int help;
}
	;

struct excitation{
	/* time step */
	double dt;
	/* total duration */
	double duration;
	/* rise time */
	double t0;
};

struct damping{
	double zeta;
	double consta;
	double constb;
	double freq;
};

struct properties{
	/* compressional wave velocity */
	double cp;
	/* shear wave velocity */
	double cs;
	/* density */
	double den;
}
	;

struct source{
	double dip;
	double strike;
	double rake;
	double fault;
	double xyz[3UL];
	double epixyz[3UL];
	int sourcenode;
	int epicenternode;
};
/* name of the main program */
char *progname;
struct options options;
/* global packfile variables */
FILE *packfile;
/* global Archimedes variables */
int ARCHnodes;
int ARCHpriv;
int ARCHmine;
int ARCHelems;
int ARCHglobalnodes;
int ARCHmesh_dim;
int ARCHglobalelems;
int ARCHcorners;
int ARCHsubdomains;
double ARCHduration;
int ARCHmatrixlen;
int ARCHcholeskylen;
int *ARCHglobalnode;
int *ARCHglobalelem;
double **ARCHcoord;
int **ARCHvertex;
int *ARCHmatrixcol;
int *ARCHmatrixindex;
/* functions */
void arch_init(int argc,char **argv,struct options *op);
void mem_init();
void arch_readnodevector(double *v,int n);
void slip(double *u,double *v,double *w);
double distance(double p1[],double p2[]);
void centroid(double x[][3UL],double xc[]);
double point2fault(double x[]);
void abe_matrix(double vertices[][3UL],int bv[],struct properties *prop,
                double Ce[]);
void element_matrices(double vertices[][3UL],struct properties *prop,
                      double Ke[][12UL],double Me[]);
void vv12x12(double v1[],double v2[],double u[]);
void mv12x12(double m[][12UL],double v[]);
void smvp(int nodes,double ***A,int *Acol,int *Aindex,double **v,double **w);
void smvp_opt(int nodes,double ***A,int *Acol,int *Aindex,double **v,
              double **w);
double phi0(double t,double bound);
double phi1(double t,double bound);
double phi2(double t,double bound);
/* global simulation variables */
int *nodekind;
double *nodekindf;
int *source_elms;
double **M;
double **C;
double **M23;
double **C23;
double **V23;
double **vel;
double **disp0;
double **disp1;
double **disp2;
double **K;
struct source Src;
struct excitation Exc;
struct damping Damp;
/*--------------------------------------------------------------------------*/

int main(int argc,char **argv)
{
	MPI_Init(&argc,&argv);
	ARMCI_Init();
	MPI_Comm_rank(MPI_COMM_WORLD,&__proc_id__);
	MPI_Comm_size(MPI_COMM_WORLD,&__nprocs__);

	int i;
	int j;
	int k;
	int ii;
	int jj;
	int kk;
	int iter;
	int timesteps;
	int disptplus;
	int dispt;
	int disptminus;
	int verticesonbnd;
	int cor[4UL];
	int bv[4UL];
	int Step_stride;
	double time;
	double Ke[12UL][12UL];
	double Me[12UL];
	double Ce[12UL];
	double Mexv[12UL];
	double Cexv[12UL];
	double v[12UL];
	double alpha;
	double c0[3UL];
	double d1;
	double d2;
	double bigdist1;
	double bigdist2;
	double xc[3UL];
	double uf[3UL];
	double vertices[4UL][3UL];
	struct properties prop;

	/* NOTE: There are 5 possible flag values for the node data:
	   1 if the node is in the interior 
	   4 if the node is on a x=const boundary surface
	   5 if the node is on a y=const boundary surface
	   6 if the node is on the bottom surface (z=z_lower)
	   3 if the node is on the surface (z=0) (but not along the edges)
	*/
	/*--------------------------------------------------------------------------*/
	/* Read in data from the pack file */
	arch_init(argc,argv,&options);
	/* Dynamic memory allocations and initializations */
	mem_init();
	arch_readnodevector(nodekindf,ARCHnodes);
	if (!(options.quiet != 0)) 
		fprintf(stderr,"%s: Beginning simulation.\n",argv[0]);

	/* Excitation characteristics */
	Exc.dt = 0.0024;
	Exc.duration = ARCHduration;
	Exc.t0 = 0.6;
	timesteps = ((Exc.duration / Exc.dt) + 1);
	/* Damping characteristics */
	Damp.zeta = 30.0;
	Damp.consta = 0.00533333;
	Damp.constb = 0.06666667;
	Damp.freq = 0.5;
	/* Source characteristics */
	Src.strike = 111.0 * 3.141592653589793238 / 180.0;
	Src.dip = 44.0 * 3.141592653589793238 / 180.0;
	Src.rake = 70.0 * 3.141592653589793238 / 180.0;
	Src.fault = 29.640788;
	Src.xyz[0] = 32.264153;
	Src.xyz[1] = 23.814432;
	Src.xyz[2] = -11.25;
	Src.epixyz[0] = Src.xyz[0];
	Src.epixyz[1] = Src.xyz[1];
	Src.epixyz[2] = 0.0;
	Src.sourcenode = -1;
	Src.epicenternode = -1;

	/* Prescribe slip motion */
	uf[0] = (uf[1] = (uf[2] = 0.0));
	slip((uf + 0),(uf + 1),(uf + 2));
	uf[0] *= Src.fault;
	uf[1] *= Src.fault;
	uf[2] *= Src.fault;

	/* Soil properties (homogeneous material) */
	prop.cp = 6.0;
	prop.cs = 3.2;
	prop.den = 2.0;

	/* Output frequency parameter */
	Step_stride = 30;
	disptplus = 0;
	dispt = 1;
	disptminus = 2;

	/* Case info */
	fprintf(stderr,"\n");
	fprintf(stderr,"CASE SUMMARY\n");
	fprintf(stderr,"Fault information\n");
	fprintf(stderr,"  Orientation:  strike: %f\n",Src.strike);
	fprintf(stderr,"                   dip: %f\n",Src.dip);
	fprintf(stderr,"                  rake: %f\n",Src.rake);
	fprintf(stderr,"           dislocation: %f cm\n",Src.fault);
	fprintf(stderr,"Hypocenter: (%f, %f, %f) Km\n",Src.xyz[0],Src.xyz[1],Src.xyz[2]);
	fprintf(stderr,"Excitation characteristics\n");
	fprintf(stderr,"     Time step: %f sec\n",Exc.dt);
	fprintf(stderr,"      Duration: %f sec\n",Exc.duration);
	fprintf(stderr,"     Rise time: %f sec\n",Exc.t0);
	fprintf(stderr,"\n");
	fflush(stderr);
	{
		/* Redefine nodekind to be 1 for all surface nodes */
		for (i = 0; i < ARCHnodes; i++) {
			nodekind[i] = ((int )nodekindf[i]);
			if (nodekind[i] == 3) 
				nodekind[i] = 1;
		}
		/* Search for the node closest to the point source (hypocenter) and */
		/*        for the node closest to the epicenter */
		bigdist1 = 1000000.0;
		bigdist2 = 1000000.0;
	}
	{
		for (i = 0; i < ARCHnodes; i++) {
			c0[0] = ARCHcoord[i][0];
			c0[1] = ARCHcoord[i][1];
			c0[2] = ARCHcoord[i][2];
			d1 = distance(c0,Src.xyz);
			d2 = distance(c0,Src.epixyz);
			if (d1 < bigdist1) {
				bigdist1 = d1;
				Src.sourcenode = i;
			}
			if (d2 < bigdist2) {
				bigdist2 = d2;
				Src.epicenternode = i;
			}
		}
	}
	if ((Src.sourcenode != 0) && (Src.sourcenode <= ARCHmine)) {
		fprintf(stderr,"The source is node %d at (%f  %f  %f)\n",
		        ARCHglobalnode[Src.sourcenode],ARCHcoord[Src.sourcenode][0],
		        ARCHcoord[Src.sourcenode][1],ARCHcoord[Src.sourcenode][2]);
		fflush(stderr);
	}

	if ((Src.epicenternode != 0) && (Src.epicenternode <= ARCHmine)) {
		fprintf(stderr,"The epicenter is node %d at (%f  %f  %f)\n",
		        ARCHglobalnode[Src.epicenternode],
		        ARCHcoord[Src.epicenternode][0],
		        ARCHcoord[Src.epicenternode][1],
		        ARCHcoord[Src.epicenternode][2]);
		fflush(stderr);
	}
	/* Search for all the elements that contain the source node */
	if (Src.sourcenode != 0) {
		for (i = 0; i < ARCHelems; i++) {{
				for (j = 0; j < 4; j++)
					cor[j] = ARCHvertex[i][j];
			}
			if ((((cor[0] == Src.sourcenode) || (cor[1] == Src.sourcenode)) ||
			     (cor[2] == Src.sourcenode)) || (cor[3] == Src.sourcenode)) {{
					for (j = 0; j < 4; j++) 
						for (k = 0; k < 3; k++) 
							vertices[j][k] = ARCHcoord[cor[j]][k];
					centroid(vertices,xc);
					source_elms[i] = 2;
				}
				if (point2fault(xc) >= 0) 
					source_elms[i] = 3;
			}
		}
	}
	/* Simulation */
	for (i = 0; i < ARCHelems; i++) {{
			for (j = 0; j < 12; j++) {
				Me[j] = 0.0;
				Ce[j] = 0.0;
				v[j] = 0.0;
				for (k = 0; k < 12; k++) 
					Ke[j][k] = 0.0;
			}
			for (j = 0; j < 4; j++) {
				cor[j] = ARCHvertex[i][j];
			}
			verticesonbnd = 0;
		}
		for (j = 0; j < 4; j++) 
			if (nodekind[cor[j]] != 1) 
				bv[verticesonbnd++] = j;
		if (verticesonbnd == 3) {{
				for (j = 0; j < 3; j++) 
					for (k = 0; k < 3; k++) 
						vertices[j][k] = ARCHcoord[cor[bv[j]]][k];
			}
			abe_matrix(vertices,bv,&prop,Ce);
		}
		{
			for (j = 0; j < 4; j++) 
				for (k = 0; k < 3; k++) 
					vertices[j][k] = ARCHcoord[cor[j]][k];
		}
		element_matrices(vertices,&prop,Ke,Me);
		{
			/* Damping (proportional) */
			centroid(vertices,xc);
			if (xc[2] < -11.5) 
				alpha = (((2.0 * Damp.zeta) / 100.0) *
				         (2.0 * 3.141592653589793238 * Damp.freq));
			else 
				alpha = (((4.0 * 3.141592653589793238 * Damp.consta) * 0.95) /
				         (prop.cs + Damp.constb));
			for (j = 0; j < 12; j++) 
				Ce[j] = (Ce[j] + (alpha * Me[j]));
		}
		/* Source mechanism */
		if ((source_elms[i] == 2) || (source_elms[i] == 3)) {
			for (j = 0; j < 4; j++) {
				if (cor[j] == Src.sourcenode) {
					v[3 * j] = uf[0];
					v[(3 * j) + 1] = uf[1];
					v[(3 * j) + 2] = uf[2];
				}
				else {
					v[3 * j] = 0;
					v[(3 * j) + 1] = 0;
					v[(3 * j) + 2] = 0;
				}
			}
			{
				vv12x12(Me,v,Mexv);
				vv12x12(Ce,v,Cexv);
				mv12x12(Ke,v);
				if (source_elms[i] == 3) 
					for (j = 0; j < 12; j++) {
						v[j] = -v[j];
						Mexv[j] = -Mexv[j];
						Cexv[j] = -Cexv[j];
					}
			}
			/* Assemble vectors3 V23, M23, C23 */
			for (j = 0; j < 4; j++) {
				V23[ARCHvertex[i][j]][0] += v[j * 3];
				V23[ARCHvertex[i][j]][1] += v[(j * 3) + 1];
				V23[ARCHvertex[i][j]][2] += v[(j * 3) + 2];
				M23[ARCHvertex[i][j]][0] += Mexv[j * 3];
				M23[ARCHvertex[i][j]][1] += Mexv[(j * 3) + 1];
				M23[ARCHvertex[i][j]][2] += Mexv[(j * 3) + 2];
				C23[ARCHvertex[i][j]][0] += Cexv[j * 3];
				C23[ARCHvertex[i][j]][1] += Cexv[(j * 3) + 1];
				C23[ARCHvertex[i][j]][2] += Cexv[(j * 3) + 2];
			}
		}
		/* Assemble vectors3 Me, Ce and matrix3 Ke */
		for (j = 0; j < 4; j++) {
			M[ARCHvertex[i][j]][0] += Me[j * 3];
			M[ARCHvertex[i][j]][1] += Me[(j * 3) + 1];
			M[ARCHvertex[i][j]][2] += Me[(j * 3) + 2];
			C[ARCHvertex[i][j]][0] += Ce[j * 3];
			C[ARCHvertex[i][j]][1] += Ce[(j * 3) + 1];
			C[ARCHvertex[i][j]][2] += Ce[(j * 3) + 2];
			for (k = 0; k < 4; k++) {
				if (ARCHvertex[i][j] <= ARCHvertex[i][k]) {
					kk = ARCHmatrixindex[ARCHvertex[i][j]];
					while(ARCHmatrixcol[kk] != ARCHvertex[i][k]){
						kk++;
						if (kk >= ARCHmatrixindex[ARCHvertex[i][k] + 1]) {
							printf("K indexing error!!! %d %d\n",
							       ARCHvertex[i][j],ARCHvertex[i][k]);
							exit(1);
						}
					}
					for (ii = 0; ii < 3; ii++) 
						for (jj = 0; jj < 3; jj++) 
							K[kk][(ii * 3) + jj] +=
								Ke[(j * 3) + ii][(k * 3) + jj];
				}
			}
		}
	}

	/* Time integration loop */
	fprintf(stderr,"\n");
	double sum0;
	double sum1;
	double sum2;
	int Anext;
	int Alast;
	int col;
	int stride1 = 3;
	int stride2 = 9;
	double Exc_dt = Exc.dt;
	double Exc_t0 = Exc.t0;

#pragma arrays disp0 [ ARCHnodes ] [ 3 ], disp1 [ ARCHnodes ] [ 3 ],	  \
	disp2 [ ARCHnodes ] [ 3 ], K [ ARCHmatrixlen ] [ 9 ], \
	M [ ARCHnodes ] [ 3 ], C [ ARCHnodes ] [ 3 ], vel [ ARCHnodes ] [ 3 ], \
	M23 [ ARCHnodes ] [ 3 ], C23 [ ARCHnodes ] [ 3 ], V23 [ ARCHnodes ] [ 3 ], \
	ARCHmatrixindex [ ARCHnodes + 1 ] [ 1 ], \
	ARCHmatrixcol [ ARCHmatrixlen ] [ 1 ]

	// Each team takes care of one loop
	const int nLoops = 15;

	// Each team must have the same number of processes
	if (__nprocs__ % nLoops != 0){

		printf("ERROR - #procs must be multiple of the pipeline depth\n");
		ARMCI_Finalize();
		MPI_Finalize();
		return -1;
	}
	const int teamSize = __nprocs__ / nLoops;
	const int myTeam = __proc_id__ / teamSize;
	const int idInMyTeam = __proc_id__ % teamSize;

	int iter_num_count[15] = {ARCHnodes - 0, ARCHnodes - 0, ARCHnodes - 0,
	                          ARCHnodes - 0, ARCHnodes - 0, ARCHnodes - 0,
	                          ARCHnodes - 0, ARCHnodes - 0, ARCHnodes - 0,
	                          ARCHnodes - 0, ARCHnodes - 0, ARCHnodes - 0,
	                          ARCHnodes - 0, ARCHnodes - 0, ARCHnodes - 0};
	int data_num_count[10] = {ARCHnodes, ARCHnodes, ARCHnodes, ARCHnodes,
	                          ARCHnodes, ARCHnodes, ARCHnodes, ARCHnodes,
	                          ARCHnodes,  ARCHmatrixlen};
	int ro_mask[10] = {1, 1, 1, 1, 1, 0, 0, 0, 0, 1};

	create_inspector(__proc_id__, __nprocs__, myTeam, idInMyTeam, teamSize,
	                 nLoops, 10, 2, iter_num_count, data_num_count, ro_mask);

	// Set parameters for the indirection arrays
	// (0 = ARCHmatrixcol, 1 = ARCHmatrixindex)
	int __size_ARCHmatrixcol__ =  ARCHmatrixlen;
	set_access_array_param(0, ARCHmatrixlen, 1,
	                       __size_ARCHmatrixcol__ / teamSize * idInMyTeam +
	                       ARCHmatrixcol);

	int __size_ARCHmatrixindex__ =  ARCHnodes + 1 ;
	set_access_array_param(1, ARCHnodes + 1, 1,
	                       __size_ARCHmatrixindex__ / teamSize * idInMyTeam +
	                       ARCHmatrixindex);

	// Set stride for data arrays. The stride is taken directly from the pragma.
	set_array_stride(0, 3); // M
	set_array_stride(1, 3); // C
	set_array_stride(2, 3); // M23
	set_array_stride(3, 3); // C23
	set_array_stride(4, 3); // V23
	set_array_stride(5, 3); // vel
	set_array_stride(6, 3); // disp0
	set_array_stride(7, 3); // disp1
	set_array_stride(8, 3); // disp2
	set_array_stride(9, 9); // K

	// Initial limits for loop 0
	int __local_block_0_start__ = (ARCHnodes - 0) / teamSize * idInMyTeam + 0;
	int __local_block_0_end__;
	if (idInMyTeam != teamSize - 1)
		__local_block_0_end__ =
			(ARCHnodes - 0) / teamSize * (idInMyTeam + 1) + 0;
	else
		__local_block_0_end__ = ARCHnodes;
	int *__0_status__ = (int *)(malloc(sizeof(int ) *
	                                   (__local_block_0_end__ -
	                                    __local_block_0_start__)));
	memset(__0_status__, 0,
	       sizeof(int ) * (__local_block_0_end__ - __local_block_0_start__));

	// Initial limits for loop 1
	int __local_block_1_start__ = (ARCHnodes - 0) / teamSize * idInMyTeam + 0;
	int __local_block_1_end__;
	if (idInMyTeam != teamSize - 1)
		__local_block_1_end__ =
			(ARCHnodes - 0) / teamSize * (idInMyTeam + 1) + 0;
	else
		__local_block_1_end__ = ARCHnodes;
	int *__1_status__ =
		(int*)(malloc(sizeof(int ) *
		               (__local_block_1_end__ - __local_block_1_start__)));
	memset(__1_status__, 0,
	       sizeof(int) * (__local_block_1_end__ - __local_block_1_start__));

	// Initial limits for loop 2
	int __local_block_2_start__ = (ARCHnodes - 0) / teamSize * idInMyTeam + 0;
	int __local_block_2_end__;
	if (idInMyTeam != teamSize - 1)
		__local_block_2_end__ =
			(ARCHnodes - 0) / teamSize * (idInMyTeam + 1) + 0;
	else
		__local_block_2_end__ = ARCHnodes;
	int *__2_status__ =
		(int*)(malloc(sizeof(int ) *
		               (__local_block_2_end__ - __local_block_2_start__)));
	memset(__2_status__, 0,
	       sizeof(int) * (__local_block_2_end__ - __local_block_2_start__));

	// Initial limits for loop 3
	int __local_block_3_start__ = (ARCHnodes - 0) / teamSize * idInMyTeam + 0;
	int __local_block_3_end__;
	if (idInMyTeam != teamSize - 1)
		__local_block_3_end__ =
			(ARCHnodes - 0) / teamSize * (idInMyTeam + 1) + 0;
	else
		__local_block_3_end__ = ARCHnodes;
	int *__3_status__ =
		(int*)(malloc(sizeof(int ) *
		               (__local_block_3_end__ - __local_block_3_start__)));
	memset(__3_status__, 0,
	       sizeof(int) * (__local_block_3_end__ - __local_block_3_start__));

	// Initial limits for loop 4
	int __local_block_4_start__ = (ARCHnodes - 0) / teamSize * idInMyTeam + 0;
	int __local_block_4_end__;
	if (idInMyTeam != teamSize - 1)
		__local_block_4_end__ =
			(ARCHnodes - 0) / teamSize * (idInMyTeam + 1) + 0;
	else
		__local_block_4_end__ = ARCHnodes;
	int *__4_status__ =
		(int*)(malloc(sizeof(int ) *
		               (__local_block_4_end__ - __local_block_4_start__)));
	memset(__4_status__, 0,
	       sizeof(int) * (__local_block_4_end__ - __local_block_4_start__));

	// Initial limits for loop 5
	int __local_block_5_start__ = (ARCHnodes - 0) / teamSize * idInMyTeam + 0;
	int __local_block_5_end__;
	if (idInMyTeam != teamSize - 1)
		__local_block_5_end__ =
			(ARCHnodes - 0) / teamSize * (idInMyTeam + 1) + 0;
	else
		__local_block_5_end__ = ARCHnodes;
	int *__5_status__ =
		(int*)(malloc(sizeof(int ) *
		               (__local_block_5_end__ - __local_block_5_start__)));
	memset(__5_status__, 0,
	       sizeof(int) * (__local_block_5_end__ - __local_block_5_start__));

	// Initial limits for loop 6
	int __local_block_6_start__ = (ARCHnodes - 0) / teamSize * idInMyTeam + 0;
	int __local_block_6_end__;
	if (idInMyTeam != teamSize - 1)
		__local_block_6_end__ =
			(ARCHnodes - 0) / teamSize * (idInMyTeam + 1) + 0;
	else
		__local_block_6_end__ = ARCHnodes;
	int *__6_status__ =
		(int*)(malloc(sizeof(int ) *
		               (__local_block_6_end__ - __local_block_6_start__)));
	memset(__6_status__, 0,
	       sizeof(int) * (__local_block_6_end__ - __local_block_6_start__));

	// Initial limits for loop 7
	int __local_block_7_start__ = (ARCHnodes - 0) / teamSize * idInMyTeam + 0;
	int __local_block_7_end__;
	if (idInMyTeam != teamSize - 1)
		__local_block_7_end__ =
			(ARCHnodes - 0) / teamSize * (idInMyTeam + 1) + 0;
	else
		__local_block_7_end__ = ARCHnodes;
	int *__7_status__ =
		(int*)(malloc(sizeof(int ) *
		               (__local_block_7_end__ - __local_block_7_start__)));
	memset(__7_status__, 0,
	       sizeof(int) * (__local_block_7_end__ - __local_block_7_start__));

	// Initial limits for loop 8
	int __local_block_8_start__ = (ARCHnodes - 0) / teamSize * idInMyTeam + 0;
	int __local_block_8_end__;
	if (idInMyTeam != teamSize - 1)
		__local_block_8_end__ =
			(ARCHnodes - 0) / teamSize * (idInMyTeam + 1) + 0;
	else
		__local_block_8_end__ = ARCHnodes;
	int *__8_status__ =
		(int*)(malloc(sizeof(int ) *
		               (__local_block_8_end__ - __local_block_8_start__)));
	memset(__8_status__, 0,
	       sizeof(int) * (__local_block_8_end__ - __local_block_8_start__));

	// Initial limits for loop 9
	int __local_block_9_start__ = (ARCHnodes - 0) / teamSize * idInMyTeam + 0;
	int __local_block_9_end__;
	if (idInMyTeam != teamSize - 1)
		__local_block_9_end__ =
			(ARCHnodes - 0) / teamSize * (idInMyTeam + 1) + 0;
	else
		__local_block_9_end__ = ARCHnodes;
	int *__9_status__ =
		(int*)(malloc(sizeof(int ) *
		               (__local_block_9_end__ - __local_block_9_start__)));
	memset(__9_status__, 0,
	       sizeof(int) * (__local_block_9_end__ - __local_block_9_start__));

	// Initial limits for loop 10
	int __local_block_10_start__ = (ARCHnodes - 0) / teamSize * idInMyTeam + 0;
	int __local_block_10_end__;
	if (idInMyTeam != teamSize - 1)
		__local_block_10_end__ =
			(ARCHnodes - 0) / teamSize * (idInMyTeam + 1) + 0;
	else
		__local_block_10_end__ = ARCHnodes;
	int *__10_status__ =
		(int*)(malloc(sizeof(int ) *
		               (__local_block_10_end__ - __local_block_10_start__)));
	memset(__10_status__, 0,
	       sizeof(int) * (__local_block_10_end__ - __local_block_10_start__));

	// Initial limits for loop 11
	int __local_block_11_start__ = (ARCHnodes - 0) / teamSize * idInMyTeam + 0;
	int __local_block_11_end__;
	if (idInMyTeam != teamSize - 1)
		__local_block_11_end__ =
			(ARCHnodes - 0) / teamSize * (idInMyTeam + 1) + 0;
	else
		__local_block_11_end__ = ARCHnodes;
	int *__11_status__ =
		(int*)(malloc(sizeof(int ) *
		               (__local_block_11_end__ - __local_block_11_start__)));
	memset(__11_status__, 0,
	       sizeof(int) * (__local_block_11_end__ - __local_block_11_start__));

	// Initial limits for loop 12
	int __local_block_12_start__ = (ARCHnodes - 0) / teamSize * idInMyTeam + 0;
	int __local_block_12_end__;
	if (idInMyTeam != teamSize - 1)
		__local_block_12_end__ =
			(ARCHnodes - 0) / teamSize * (idInMyTeam + 1) + 0;
	else
		__local_block_12_end__ = ARCHnodes;
	int *__12_status__ =
		(int*)(malloc(sizeof(int ) *
		               (__local_block_12_end__ - __local_block_12_start__)));
	memset(__12_status__, 0,
	       sizeof(int) * (__local_block_12_end__ - __local_block_12_start__));

	// Initial limits for loop 13
	int __local_block_13_start__ = (ARCHnodes - 0) / teamSize * idInMyTeam + 0;
	int __local_block_13_end__;
	if (idInMyTeam != teamSize - 1)
		__local_block_13_end__ =
			(ARCHnodes - 0) / teamSize * (idInMyTeam + 1) + 0;
	else
		__local_block_13_end__ = ARCHnodes;
	int *__13_status__ =
		(int*)(malloc(sizeof(int ) *
		               (__local_block_13_end__ - __local_block_13_start__)));
	memset(__13_status__, 0,
	       sizeof(int) * (__local_block_13_end__ - __local_block_13_start__));

	// Initial limits for loop 14
	int __local_block_14_start__ = (ARCHnodes - 0) / teamSize * idInMyTeam + 0;
	int __local_block_14_end__;
	if (idInMyTeam != teamSize - 1)
		__local_block_14_end__ =
			(ARCHnodes - 0) / teamSize * (idInMyTeam + 1) + 0;
	else
		__local_block_14_end__ = ARCHnodes;
	int *__14_status__ =
		(int*)(malloc(sizeof(int ) *
		               (__local_block_14_end__ - __local_block_14_start__)));
	memset(__14_status__, 0,
	       sizeof(int) * (__local_block_14_end__ - __local_block_14_start__));

	/*
	 * INSPECTOR
	 */

	/* STAGE 1: create hypergraph and partition */
	int __shadow_0__ = 0;
	int __shadow_1__ = 0;

	// Pipeline array usage initialization
	const int usedArraysLoop0[1] = {6};
	const int usedArraysLoop1[3] = {6, 7, 9};
	const int usedArraysLoop2[8] = {0, 1, 2, 3, 4, 6, 7, 8};
	const int usedArraysLoop3[3] = {0, 1, 6};
	const int usedArraysLoop4[3] = {5, 6, 8};
	const int usedArraysLoop5[1] = {8};
	const int usedArraysLoop6[3] = {6, 8, 9};
	const int usedArraysLoop7[8] = {0, 1, 2, 3, 4, 6, 7, 8};
	const int usedArraysLoop8[3] = {0, 1, 8};
	const int usedArraysLoop9[3] = {5, 7, 8};
	const int usedArraysLoop10[1] = {7};
	const int usedArraysLoop11[3] = {7, 8, 9};
	const int usedArraysLoop12[8] = {0, 1, 2, 3, 4, 6, 7, 8};
	const int usedArraysLoop13[3] = {0, 1, 7};
	const int usedArraysLoop14[3] = {5, 6, 7};

	const int readInLoop0[1] = {0};
	const int readInLoop1[3] = {1, 1, 1};
	const int readInLoop2[8] = {1, 1, 1, 1, 1, 1, 1, 1};
	const int readInLoop3[3] = {1, 1, 1};
	const int readInLoop4[3] = {0, 1, 1};
	const int readInLoop5[1] = {0};
	const int readInLoop6[3] = {1, 1, 1};
	const int readInLoop7[8] = {1, 1, 1, 1, 1, 1, 1, 1};
	const int readInLoop8[3] = {1, 1, 1};
	const int readInLoop9[3] = {0, 1, 1};
	const int readInLoop10[1] = {1};
	const int readInLoop11[3] = {1, 1, 1};
	const int readInLoop12[8] = {1, 1, 1, 1, 1, 1, 1, 1};
	const int readInLoop13[3] = {1, 1, 1};
	const int readInLoop14[3] = {0, 1, 1};

	const int writeInLoop0[1] = {1};
	const int writeInLoop1[3] = {1, 0, 0};
	const int writeInLoop2[8] = {0, 0, 0, 0, 0, 1, 0, 0};
	const int writeInLoop3[3] = {0, 0, 1};
	const int writeInLoop4[3] = {1, 0, 0};
	const int writeInLoop5[1] = {1};
	const int writeInLoop6[3] = {0, 1, 0};
	const int writeInLoop7[8] = {0, 0, 0, 0, 0, 0, 0, 1};
	const int writeInLoop8[3] = {0, 0, 1};
	const int writeInLoop9[3] = {1, 0, 0};
	const int writeInLoop10[1] = {1};
	const int writeInLoop11[3] = {1, 0, 0};
	const int writeInLoop12[8] = {0, 0, 0, 0, 0, 0, 1, 0};
	const int writeInLoop13[3] = {0, 0, 1};
	const int writeInLoop14[3] = {1, 0, 0};

	const int lastWrite0[] = {0};
	const int lastWrite1[] = {0, 0, 0};
	const int lastWrite2[] = {0, 0, 0, 0, 0, 0, 0, 0};
	const int lastWrite3[] = {0, 0, 1};
	const int lastWrite4[] = {0, 0, 0};
	const int lastWrite5[] = {0};
	const int lastWrite6[] = {0, 0, 0};
	const int lastWrite7[] = {0, 0, 0, 0, 0, 0, 0, 0};
	const int lastWrite8[] = {0, 0, 1};
	const int lastWrite9[] = {0, 0, 0};
	const int lastWrite10[] = {0};
	const int lastWrite11[] = {0, 0, 0};
	const int lastWrite12[] = {0, 0, 0, 0, 0, 0, 0, 0};
	const int lastWrite13[] = {0, 0, 1};
	const int lastWrite14[] = {1, 0, 0};

	pipe_init_loop(0, usedArraysLoop0, readInLoop0, writeInLoop0,
	               lastWrite0, 1);
	pipe_init_loop(1, usedArraysLoop1, readInLoop1, writeInLoop1,
	               lastWrite1, 3);
	pipe_init_loop(2, usedArraysLoop2, readInLoop2, writeInLoop2,
	               lastWrite2, 8);
	pipe_init_loop(3, usedArraysLoop3, readInLoop3, writeInLoop3,
	               lastWrite3, 3);
	pipe_init_loop(4, usedArraysLoop4, readInLoop4, writeInLoop4,
	               lastWrite4, 3);
	pipe_init_loop(5, usedArraysLoop5, readInLoop5, writeInLoop5,
	               lastWrite5, 1);
	pipe_init_loop(6, usedArraysLoop6, readInLoop6, writeInLoop6,
	               lastWrite6, 3);
	pipe_init_loop(7, usedArraysLoop7, readInLoop7, writeInLoop7,
	               lastWrite7, 8);
	pipe_init_loop(8, usedArraysLoop8, readInLoop8, writeInLoop8,
	               lastWrite8, 3);
	pipe_init_loop(9, usedArraysLoop9, readInLoop9, writeInLoop9,
	               lastWrite9, 3);
	pipe_init_loop(10, usedArraysLoop10, readInLoop10, writeInLoop10,
	               lastWrite10, 1);
	pipe_init_loop(11, usedArraysLoop11, readInLoop11, writeInLoop11,
	               lastWrite11, 3);
	pipe_init_loop(12, usedArraysLoop12, readInLoop12, writeInLoop12,
	               lastWrite12, 8);
	pipe_init_loop(13, usedArraysLoop13, readInLoop13, writeInLoop13,
	               lastWrite13, 3);
	pipe_init_loop(14, usedArraysLoop14, readInLoop14, writeInLoop14,
	               lastWrite14, 3);

	do {

		//Loop 0
		for (i = __local_block_0_start__; i < __local_block_0_end__; i++)
			if (__0_status__[i - __local_block_0_start__] == 0) {
				__0_status__[i - __local_block_0_start__] = 1;
				add_vertex(0, i);
				add_pin_to_net(6, i, 0, i, 1, 1);
			}

		//Loop 1
		__shadow_0__ = 0;
		__shadow_1__ = 0;
		for (i = __local_block_1_start__; i < __local_block_1_end__; i++)
			if (__1_status__[i - __local_block_1_start__] == 0) {
				__1_status__[i - __local_block_1_start__] = 1;

				add_vertex(0, i);
				if (is_known(1, i)) {
					Anext = get_elem(1, i);
					__shadow_0__ = 1;
				}
				else {
					__1_status__[i - __local_block_1_start__] = 0;
					__shadow_0__ = 0;
				}
				if (__shadow_0__ != 0)
					add_pin_to_net(9, Anext, 1, i, 0, 0);
				else
					__1_status__[i - __local_block_1_start__] = 0;
				add_pin_to_net(7, i, 1, i, 1, 1);
				if (is_known(1, i) && is_known(1, i + 1))
					for (j = (get_elem(1,i) + 1);
					     j < get_elem(1, i + 1);
					     j++){

							if (is_known(0,j)) {
								col = get_elem(0,j);
								__shadow_1__ = 1;
							}
							else {
								__1_status__[i - __local_block_1_start__] = 0;
								__shadow_1__ = 0;
							}
							add_pin_to_net(9, j, 1, i, 1, 0);
							if (__shadow_1__ != 0)
								add_pin_to_net(7, col, 1, i, 0, 0);
							else
								__1_status__[i - __local_block_1_start__] = 0;
							if (__shadow_1__ != 0)
								add_pin_to_net(6, col, 1, i, 0, 0);
							else
								__1_status__[i - __local_block_1_start__] = 0;
					}
				else {
					__shadow_1__ = 0;
					__1_status__[i - __local_block_1_start__] = 0;
				}
				add_pin_to_net(6, i, 1, i, 1, 1);
			}

		//Loop 2
		for (i = __local_block_2_start__; i < __local_block_2_end__; i++)
			if (__2_status__[i - __local_block_2_start__] == 0){
				__2_status__[i - __local_block_2_start__] = 1;
				add_vertex(0,i);
				add_pin_to_net(6, i, 2, i, 1, 1);
				add_pin_to_net(0, i, 2, i, 1, 1);
				add_pin_to_net(7, i, 2, i, 1, 1);
				add_pin_to_net(1, i, 2, i, 1, 1);
				add_pin_to_net(8, i, 2, i, 1, 1);
				add_pin_to_net(2, i, 2, i, 1, 1);
				add_pin_to_net(3, i, 2, i, 1, 1);
				add_pin_to_net(4, i, 2, i, 1, 1);
			}

		//Loop 3
		for (i = __local_block_3_start__; i < __local_block_3_end__; i++)
			if (__3_status__[i - __local_block_3_start__] == 0) {
				__3_status__[i - __local_block_3_start__] = 1;
				add_vertex(0,i);
				add_pin_to_net(6, i, 3, i, 1, 1);
				add_pin_to_net(0, i, 3, i, 1, 1);
				add_pin_to_net(1, i, 3, i, 1, 1);
			}

		//Loop 4
		for (i = __local_block_4_start__; i < __local_block_4_end__; i++)
			if (__4_status__[i - __local_block_4_start__] == 0) {
				__4_status__[i - __local_block_4_start__] = 1;
				add_vertex(0,i);
				add_pin_to_net(5, i, 4, i, 1, 1);
				add_pin_to_net(6, i, 4, i, 1, 1);
				add_pin_to_net(8, i, 4, i, 1, 1);
			}

		//Loop 5
		for (i = __local_block_5_start__; i < __local_block_5_end__; i++)
			if (__5_status__[i - __local_block_5_start__] == 0) {
				__5_status__[i - __local_block_5_start__] = 1;
				add_vertex(0,i);
				add_pin_to_net(8, i, 5, i, 1, 1);
			}

		//Loop 6
		__shadow_0__ = 0;
		__shadow_1__ = 0;
		for (i = __local_block_6_start__; i < __local_block_6_end__; i++)
			if (__6_status__[i - __local_block_6_start__] == 0) {
				__6_status__[i - __local_block_6_start__] = 1;
				add_vertex(0,i);
				{
					if (is_known(1,i)) {
						Anext = get_elem(1,i);
						__shadow_0__ = 1;
					}
					else {
						__6_status__[i - __local_block_6_start__] = 0;
						__shadow_0__ = 0;
					}
					if (__shadow_0__ != 0)
						add_pin_to_net(9, Anext, 6, i, 0, 0);
					else
						__6_status__[i - __local_block_6_start__] = 0;
					add_pin_to_net(6, i, 6, i, 1, 1);
					if (is_known(1,i) && is_known(1,i + 1))
						for (j = (get_elem(1,i) + 1); j < get_elem(1,i + 1); j++) {{
								if (is_known(0,j)) {
									col = get_elem(0,j);
									__shadow_1__ = 1;
								}
								else {
									__6_status__[i - __local_block_6_start__] = 0;
									__shadow_1__ = 0;
								}
								add_pin_to_net(9, j, 6, i, 1, 0);
								if (__shadow_1__ != 0)
									add_pin_to_net(6, col, 6, i, 0, 0);
								else
									__6_status__[i - __local_block_6_start__] = 0;
								if (__shadow_1__ != 0)
									add_pin_to_net(8, col, 6, i, 0, 0);
								else
									__6_status__[i - __local_block_6_start__] = 0;;
							};
						}
					else {
						__shadow_1__ = 0;
						__6_status__[i - __local_block_6_start__] = 0;;
					}
					add_pin_to_net(8, i, 6, i, 1, 1);
				};
			}

		//Loop 7
		for (i = __local_block_7_start__; i < __local_block_7_end__; i++)
			if (__7_status__[i - __local_block_7_start__] == 0) {
				__7_status__[i - __local_block_7_start__] = 1;
				add_vertex(0,i);
				add_pin_to_net(8, i, 7, i, 1, 1);
				add_pin_to_net(0, i, 7, i, 1, 1);
				add_pin_to_net(6, i, 7, i, 1, 1);
				add_pin_to_net(1, i, 7, i, 1, 1);
				add_pin_to_net(7, i, 7, i, 1, 1);
				add_pin_to_net(2, i, 7, i, 1, 1);
				add_pin_to_net(3, i, 7, i, 1, 1);
				add_pin_to_net(4, i, 7, i, 1, 1);
			}

		//Loop 8
		for (i = __local_block_8_start__; i < __local_block_8_end__; i++)
			if (__8_status__[i - __local_block_8_start__] == 0) {
				__8_status__[i - __local_block_8_start__] = 1;
				add_vertex(0,i);
				add_pin_to_net(8, i, 8, i, 1, 1);
				add_pin_to_net(0, i, 8, i, 1, 1);
				add_pin_to_net(1, i, 8, i, 1, 1);
			}

		//Loop 9
		for (i = __local_block_9_start__; i < __local_block_9_end__; i++)
			if (__9_status__[i - __local_block_9_start__] == 0) {
				__9_status__[i - __local_block_9_start__] = 1;
				add_vertex(0,i);
				add_pin_to_net(5, i, 9, i, 1, 1);
				add_pin_to_net(8, i, 9, i, 1, 1);
				add_pin_to_net(7, i, 9, i, 1, 1);
			}

		//Loop 10
		for (i = __local_block_10_start__; i < __local_block_10_end__; i++)
			if (__10_status__[i - __local_block_10_start__] == 0) {
				__10_status__[i - __local_block_10_start__] = 1;
				add_vertex(0,i);
				add_pin_to_net(7, i, 10, i, 1, 1);
			}

		//Loop 11
		__shadow_0__ = 0;
		__shadow_1__ = 0;
		for (i = __local_block_11_start__; i < __local_block_11_end__; i++)
			if (__11_status__[i - __local_block_11_start__] == 0) {
				__11_status__[i - __local_block_11_start__] = 1;
				add_vertex(0,i);
				{
					if (is_known(1,i)) {
						Anext = get_elem(1,i);
						__shadow_0__ = 1;
					}
					else {
						__11_status__[i - __local_block_11_start__] = 0;
						__shadow_0__ = 0;
					}
					if (__shadow_0__ != 0)
						add_pin_to_net(9, Anext, 11, i, 0, 0);
					else
						__11_status__[i - __local_block_11_start__] = 0;
					add_pin_to_net(8, i, 11, i, 1, 1);
					if (is_known(1,i) && is_known(1,i + 1))
						for (j = (get_elem(1,i) + 1); j < get_elem(1,i + 1); j++) {{
								if (is_known(0,j)) {
									col = get_elem(0,j);
									__shadow_1__ = 1;
								}
								else {
									__11_status__[i - __local_block_11_start__] = 0;
									__shadow_1__ = 0;
								}
								add_pin_to_net(9, j, 11, i, 1, 0);
								if (__shadow_1__ != 0)
									add_pin_to_net(8, col, 11, i, 0, 0);
								else
									__11_status__[i - __local_block_11_start__] = 0;
								if (__shadow_1__ != 0)
									add_pin_to_net(7, col, 11, i, 0, 0);
								else
									__11_status__[i - __local_block_11_start__] = 0;
							};
						}
					else {
						__shadow_1__ = 0;
						__11_status__[i - __local_block_11_start__] = 0;;
					}
					add_pin_to_net(7, i, 11, i, 1, 1);
				};
			}

		//Loop 12
		for (i = __local_block_12_start__; i < __local_block_12_end__; i++)
			if (__12_status__[i - __local_block_12_start__] == 0) {
				__12_status__[i - __local_block_12_start__] = 1;
				add_vertex(0,i);
				add_pin_to_net(7, i, 12, i, 1, 1);
				add_pin_to_net(0, i, 12, i, 1, 1);
				add_pin_to_net(8, i, 12, i, 1, 1);
				add_pin_to_net(1, i, 12, i, 1, 1);
				add_pin_to_net(6, i, 12, i, 1, 1);
				add_pin_to_net(2, i, 12, i, 1, 1);
				add_pin_to_net(3, i, 12, i, 1, 1);
				add_pin_to_net(4, i, 12, i, 1, 1);
			}

		//Loop 13
		for (i = __local_block_13_start__; i < __local_block_13_end__; i++)
			if (__13_status__[i - __local_block_13_start__] == 0) {
				__13_status__[i - __local_block_13_start__] = 1;
				add_vertex(0,i);
				add_pin_to_net(7, i, 13, i, 1, 1);
				add_pin_to_net(0, i, 13, i, 1, 1);
				add_pin_to_net(1, i, 13, i, 1, 1);
			}

		//Loop 14
		for (i = __local_block_14_start__; i < __local_block_14_end__; i++)
			if (__14_status__[i - __local_block_14_start__] == 0) {
				__14_status__[i - __local_block_14_start__] = 1;
				add_vertex(0,i);
				add_pin_to_net(5, i, 14, i, 1, 1);
				add_pin_to_net(7, i, 14, i, 1, 1);
				add_pin_to_net(6, i, 14, i, 1, 1);
			}
	}while (!done_graph_gen());

	partition_hypergraph(2);

	pipe_calculate_info();

	free(__0_status__);
	__0_status__ = ((int *)(malloc(sizeof(int ) * get_proc_iter_size(0))));
	memset(__0_status__,0,sizeof(int ) * get_proc_iter_size(0));
	free(__1_status__);
	__1_status__ = ((int *)(malloc(sizeof(int ) * get_proc_iter_size(0))));
	memset(__1_status__,0,sizeof(int ) * get_proc_iter_size(0));
	free(__2_status__);
	__2_status__ = ((int *)(malloc(sizeof(int ) * get_proc_iter_size(0))));
	memset(__2_status__,0,sizeof(int ) * get_proc_iter_size(0));
	free(__3_status__);
	__3_status__ = ((int *)(malloc(sizeof(int ) * get_proc_iter_size(0))));
	memset(__3_status__,0,sizeof(int ) * get_proc_iter_size(0));
	free(__4_status__);
	__4_status__ = ((int *)(malloc(sizeof(int ) * get_proc_iter_size(0))));
	memset(__4_status__,0,sizeof(int ) * get_proc_iter_size(0));
	free(__5_status__);
	__5_status__ = ((int *)(malloc(sizeof(int ) * get_proc_iter_size(0))));
	memset(__5_status__,0,sizeof(int ) * get_proc_iter_size(0));
	free(__6_status__);
	__6_status__ = ((int *)(malloc(sizeof(int ) * get_proc_iter_size(0))));
	memset(__6_status__,0,sizeof(int ) * get_proc_iter_size(0));
	free(__7_status__);
	__7_status__ = ((int *)(malloc(sizeof(int ) * get_proc_iter_size(0))));
	memset(__7_status__,0,sizeof(int ) * get_proc_iter_size(0));
	free(__8_status__);
	__8_status__ = ((int *)(malloc(sizeof(int ) * get_proc_iter_size(0))));
	memset(__8_status__,0,sizeof(int ) * get_proc_iter_size(0));
	free(__9_status__);
	__9_status__ = ((int *)(malloc(sizeof(int ) * get_proc_iter_size(0))));
	memset(__9_status__,0,sizeof(int ) * get_proc_iter_size(0));
	free(__10_status__);
	__10_status__ = ((int *)(malloc(sizeof(int ) * get_proc_iter_size(0))));
	memset(__10_status__,0,sizeof(int ) * get_proc_iter_size(0));
	free(__11_status__);
	__11_status__ = ((int *)(malloc(sizeof(int ) * get_proc_iter_size(0))));
	memset(__11_status__,0,sizeof(int ) * get_proc_iter_size(0));
	free(__12_status__);
	__12_status__ = ((int *)(malloc(sizeof(int ) * get_proc_iter_size(0))));
	memset(__12_status__,0,sizeof(int ) * get_proc_iter_size(0));
	free(__13_status__);
	__13_status__ = ((int *)(malloc(sizeof(int ) * get_proc_iter_size(0))));
	memset(__13_status__,0,sizeof(int ) * get_proc_iter_size(0));
	free(__14_status__);
	__14_status__ = ((int *)(malloc(sizeof(int ) * get_proc_iter_size(0))));
	memset(__14_status__,0,sizeof(int ) * get_proc_iter_size(0));

	/* STAGE 2: Create data structures? */
	do {

		// Loop 0
		int __0_status_counter__ = 0;
		for (i = 0; i < ARCHnodes; i++) {

			if (get_vertex_home(0,i) == __proc_id__) {

				if (__0_status__[__0_status_counter__] == 0) {
					__0_status__[__0_status_counter__] = 1;;
				}
				++__0_status_counter__;;
			}
		}

		// Loop 1
		int __1_status_counter__ = 0;
		__shadow_0__ = 0;
		__shadow_1__ = 0;
		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __proc_id__) {

				if (__1_status__[__1_status_counter__] == 0) {
					__1_status__[__1_status_counter__] = 1;
					{
						if (is_known(1,i)) {
							Anext = get_elem(1,i);
							__shadow_0__ = 1;
						}
						else {
							__1_status__[__1_status_counter__] = 0;
							__shadow_0__ = 0;
						}
						if (__shadow_0__ != 0) ;
						else 
							__1_status__[__1_status_counter__] = 0;
						if (is_known(1,i) && is_known(1,i + 1)) 

							for (j = (get_elem(1,i) + 1);
							     j < get_elem(1,i + 1);
							     j++) {

									if (is_known(0,j)) {
										col = get_elem(0,j);
										__shadow_1__ = 1;
									}
									else {
										__1_status__[__1_status_counter__] = 0;
										__shadow_1__ = 0;
									}
									if (__shadow_1__ != 0) ;
									else
										__1_status__[__1_status_counter__] = 0;
									if (__shadow_1__ != 0) ;
									else
										__1_status__[__1_status_counter__] = 0;;
							}
						else {
							__shadow_1__ = 0;
							__1_status__[__1_status_counter__] = 0;;
						};
					};
				}
				else ;
				++__1_status_counter__;;
			}
			else ;;
		}

		// Loop 2
		int __2_status_counter__ = 0;
		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __proc_id__) {
				if (__2_status__[__2_status_counter__] == 0) {
					__2_status__[__2_status_counter__] = 1;;
				}
				else ;
				++__2_status_counter__;;
			}
			else ;;
		}

		// Loop 3
		int __3_status_counter__ = 0;
		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __proc_id__) {
				if (__3_status__[__3_status_counter__] == 0) {
					__3_status__[__3_status_counter__] = 1;;
				}
				else ;
				++__3_status_counter__;;
			}
			else ;;
		}

		// Loop 4
		int __4_status_counter__ = 0;
		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __proc_id__) {
				if (__4_status__[__4_status_counter__] == 0) {
					__4_status__[__4_status_counter__] = 1;;
				}
				else ;
				++__4_status_counter__;;
			}
			else ;;
		}

		// Loop 5
		int __5_status_counter__ = 0;
		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __proc_id__) {
				if (__5_status__[__5_status_counter__] == 0) {
					__5_status__[__5_status_counter__] = 1;;
				}
				else ;
				++__5_status_counter__;;
			}
			else ;;
		}

		// Loop 6
		int __6_status_counter__ = 0;
		__shadow_0__ = 0;
		__shadow_1__ = 0;
		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __proc_id__) {
				if (__6_status__[__6_status_counter__] == 0) {
					__6_status__[__6_status_counter__] = 1;
					{
						if (is_known(1,i)) {
							Anext = get_elem(1,i);
							__shadow_0__ = 1;
						}
						else {
							__6_status__[__6_status_counter__] = 0;
							__shadow_0__ = 0;
						}
						if (__shadow_0__ != 0) ;
						else 
							__6_status__[__6_status_counter__] = 0;
						if (is_known(1,i) && is_known(1,i + 1)) 
							for (j = (get_elem(1,i) + 1);
							     j < get_elem(1,i + 1);
							     j++) {{

									if (is_known(0,j)) {
										col = get_elem(0,j);
										__shadow_1__ = 1;
									}
									else {
										__6_status__[__6_status_counter__] = 0;
										__shadow_1__ = 0;
									}
									if (__shadow_1__ != 0) ;
									else 
										__6_status__[__6_status_counter__] = 0;
									if (__shadow_1__ != 0) ;
									else 
										__6_status__[__6_status_counter__] = 0;;
								};
							}
						else {
							__shadow_1__ = 0;
							__6_status__[__6_status_counter__] = 0;;
						};
					};
				}
				else ;
				++__6_status_counter__;;
			}
			else ;;
		}

		// Loop 7
		int __7_status_counter__ = 0;
		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __proc_id__) {
				if (__7_status__[__7_status_counter__] == 0) {
					__7_status__[__7_status_counter__] = 1;;
				}
				else ;
				++__7_status_counter__;;
			}
			else ;;
		}

		// Loop 8
		int __8_status_counter__ = 0;
		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __proc_id__) {
				if (__8_status__[__8_status_counter__] == 0) {
					__8_status__[__8_status_counter__] = 1;;
				}
				else ;
				++__8_status_counter__;;
			}
			else ;;
		}

		// Loop 9
		int __9_status_counter__ = 0;
		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __proc_id__) {
				if (__9_status__[__9_status_counter__] == 0) {
					__9_status__[__9_status_counter__] = 1;;
				}
				else ;
				++__9_status_counter__;;
			}
			else ;;
		}

		// Loop 10
		int __10_status_counter__ = 0;
		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __proc_id__) {
				if (__10_status__[__10_status_counter__] == 0) {
					__10_status__[__10_status_counter__] = 1;;
				}
				else ;
				++__10_status_counter__;;
			}
			else ;;
		}

		// Loop 11
		int __11_status_counter__ = 0;
		__shadow_0__ = 0;
		__shadow_1__ = 0;
		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __proc_id__) {
				if (__11_status__[__11_status_counter__] == 0) {
					__11_status__[__11_status_counter__] = 1;
					{
						if (is_known(1,i)) {
							Anext = get_elem(1,i);
							__shadow_0__ = 1;
						}
						else {
							__11_status__[__11_status_counter__] = 0;
							__shadow_0__ = 0;
						}
						if (__shadow_0__ != 0) ;
						else 
							__11_status__[__11_status_counter__] = 0;
						if (is_known(1,i) && is_known(1,i + 1)) 
							for (j = (get_elem(1,i) + 1);
							     j < get_elem(1,i + 1);
							     j++) {

									if (is_known(0,j)) {
										col = get_elem(0,j);
										__shadow_1__ = 1;
									}
									else {
										__11_status__[__11_status_counter__] = 0;
										__shadow_1__ = 0;
									}
									if (__shadow_1__ != 0) ;
									else 
										__11_status__[__11_status_counter__] = 0;
									if (__shadow_1__ != 0) ;
									else 
										__11_status__[__11_status_counter__] = 0;
							}
						else {
							__shadow_1__ = 0;
							__11_status__[__11_status_counter__] = 0;;
						};
					};
				}
				else ;
				++__11_status_counter__;;
			}
			else ;;
		}

		// Loop 12
		int __12_status_counter__ = 0;
		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __proc_id__) {
				if (__12_status__[__12_status_counter__] == 0) {
					__12_status__[__12_status_counter__] = 1;;
				}
				else ;
				++__12_status_counter__;;
			}
			else ;;
		}

		// Loop 13
		int __13_status_counter__ = 0;
		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __proc_id__) {
				if (__13_status__[__13_status_counter__] == 0) {
					__13_status__[__13_status_counter__] = 1;;
				}
				else ;
				++__13_status_counter__;;
			}
			else ;;
		}

		// Loop 14
		int __14_status_counter__ = 0;
		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __proc_id__) {
				if (__14_status__[__14_status_counter__] == 0) {
					__14_status__[__14_status_counter__] = 1;;
				}
				else ;
				++__14_status_counter__;;
			}
			else ;;
		};
	}while (!done_graph_gen());
	free(__0_status__);
	free(__1_status__);
	free(__2_status__);
	free(__3_status__);
	free(__4_status__);
	free(__5_status__);
	free(__6_status__);
	free(__7_status__);
	free(__8_status__);
	free(__9_status__);
	free(__10_status__);
	free(__11_status__);
	free(__12_status__);
	free(__13_status__);
	free(__14_status__);

	/* STAGE 3: Fill in data structures? */
	__myid__ = __proc_id__;
	int __body_0__ = 0;
	int __body_1__ = 0;
	int __loop_i_6__ = 0;
	int __body_i_6__ = 0;
	int __body_2__ = 0;
	int __body_3__ = 0;
	int __body_4__ = 0;
	int __body_5__ = 0;
	int __body_6__ = 0;
	int __loop_i_11__ = 0;
	int __body_i_11__ = 0;
	int __body_7__ = 0;
	int __body_8__ = 0;
	int __body_9__ = 0;
	int __body_10__ = 0;
	int __body_11__ = 0;
	int __loop_i_16__ = 0;
	int __body_i_16__ = 0;
	int __body_12__ = 0;
	int __body_13__ = 0;
	int __body_14__ = 0;

	// Loop 0
	for (i = 0; i < ARCHnodes; i++) {
		if (get_vertex_home(0,i) == __myid__) {
			__body_0__ = __body_0__ + 1;;
		}
	}

	// Loop 1
	for (i = 0; i < ARCHnodes; i++) {
		if (get_vertex_home(0,i) == __myid__) {
			Anext = get_elem(1,i);
			for (j = (get_elem(1,i) + 1); j < get_elem(1,i + 1); j++) {{
					col = get_elem(0,j);;
				}
				__body_i_6__ = __body_i_6__ + 1;;
			}
			__loop_i_6__ = __loop_i_6__ + 1;;
			__body_1__ = __body_1__ + 1;;
		}
	}
	for (i = 0; i < ARCHnodes; i++) {
		if (get_vertex_home(0,i) == __myid__) {
			__body_2__ = __body_2__ + 1;;
		}
		else ;;
	}
	for (i = 0; i < ARCHnodes; i++) {
		if (get_vertex_home(0,i) == __myid__) {
			__body_3__ = __body_3__ + 1;;
		}
		else ;;
	}
	for (i = 0; i < ARCHnodes; i++) {
		if (get_vertex_home(0,i) == __myid__) {
			__body_4__ = __body_4__ + 1;;
		}
		else ;;
	}
	for (i = 0; i < ARCHnodes; i++) {
		if (get_vertex_home(0,i) == __myid__) {
			__body_5__ = __body_5__ + 1;;
		}
		else ;;
	}
	for (i = 0; i < ARCHnodes; i++) {
		if (get_vertex_home(0,i) == __myid__) {{
				Anext = get_elem(1,i);
				for (j = (get_elem(1,i) + 1); j < get_elem(1,i + 1); j++) {{
						col = get_elem(0,j);;
					}
					__body_i_11__ = __body_i_11__ + 1;;
				}
				__loop_i_11__ = __loop_i_11__ + 1;;
			}
			__body_6__ = __body_6__ + 1;;
		}
		else ;;
	}
	for (i = 0; i < ARCHnodes; i++) {
		if (get_vertex_home(0,i) == __myid__) {
			__body_7__ = __body_7__ + 1;;
		}
		else ;;
	}
	for (i = 0; i < ARCHnodes; i++) {
		if (get_vertex_home(0,i) == __myid__) {
			__body_8__ = __body_8__ + 1;;
		}
		else ;;
	}
	for (i = 0; i < ARCHnodes; i++) {
		if (get_vertex_home(0,i) == __myid__) {
			__body_9__ = __body_9__ + 1;;
		}
		else ;;
	}
	for (i = 0; i < ARCHnodes; i++) {
		if (get_vertex_home(0,i) == __myid__) {
			__body_10__ = __body_10__ + 1;;
		}
		else ;;
	}
	for (i = 0; i < ARCHnodes; i++) {
		if (get_vertex_home(0,i) == __myid__) {{
				Anext = get_elem(1,i);
				for (j = (get_elem(1,i) + 1); j < get_elem(1,i + 1); j++) {{
						col = get_elem(0,j);;
					}
					__body_i_16__ = __body_i_16__ + 1;;
				}
				__loop_i_16__ = __loop_i_16__ + 1;;
			}
			__body_11__ = __body_11__ + 1;;
		}
		else ;;
	}
	for (i = 0; i < ARCHnodes; i++) {
		if (get_vertex_home(0,i) == __myid__) {
			__body_12__ = __body_12__ + 1;;
		}
		else ;;
	}
	for (i = 0; i < ARCHnodes; i++) {
		if (get_vertex_home(0,i) == __myid__) {
			__body_13__ = __body_13__ + 1;;
		}
		else ;;
	}
	for (i = 0; i < ARCHnodes; i++) {
		if (get_vertex_home(0,i) == __myid__) {
			__body_14__ = __body_14__ + 1;;
		}
		else ;;
	};
	int *__i_disp0_j_5_ = (int *)(malloc(__body_i_6__ * sizeof(int )));
	int *__i_disp0_j_25_ = (int *)(malloc(__body_i_11__ * sizeof(int )));
	int *__i_disp1_j_4_ = (int *)(malloc(__body_i_6__ * sizeof(int )));
	int *__i_disp1_j_47_ = (int *)(malloc(__body_i_16__ * sizeof(int )));
	int *__i_disp2_j_26_ = (int *)(malloc(__body_i_11__ * sizeof(int )));
	int *__i_disp2_j_46_ = (int *)(malloc(__body_i_16__ * sizeof(int )));
	int *__i_K_i_1_ = (int *)(malloc(__body_1__ * sizeof(int )));
	int *__o_K_j_3_ = (int *)(malloc(__loop_i_6__ * sizeof(int )));
	int __o_K_j_3__offset;
	int *__i_K_i_22_ = (int *)(malloc(__body_6__ * sizeof(int )));
	int *__o_K_j_24_ = (int *)(malloc(__loop_i_11__ * sizeof(int )));
	int __o_K_j_24__offset;
	int *__i_K_i_43_ = (int *)(malloc(__body_11__ * sizeof(int )));
	int *__o_K_j_45_ = (int *)(malloc(__loop_i_16__ * sizeof(int )));
	int __o_K_j_45__offset;
	int __nlocal_0__ = __body_0__;
	int __nlocal_1__ = __body_1__;
	int *__lb_j_i_6__ = (int *)(malloc(__loop_i_6__ * sizeof(int )));
	int *__ub_j_i_6__ = (int *)(malloc(__loop_i_6__ * sizeof(int )));
	int __nlocal_2__ = __body_2__;
	int __nlocal_3__ = __body_3__;
	int __nlocal_4__ = __body_4__;
	int __nlocal_5__ = __body_5__;
	int __nlocal_6__ = __body_6__;
	int *__lb_j_i_11__ = (int *)(malloc(__loop_i_11__ * sizeof(int )));
	int *__ub_j_i_11__ = (int *)(malloc(__loop_i_11__ * sizeof(int )));
	int __nlocal_7__ = __body_7__;
	int __nlocal_8__ = __body_8__;
	int __nlocal_9__ = __body_9__;
	int __nlocal_10__ = __body_10__;
	int __nlocal_11__ = __body_11__;
	int *__lb_j_i_16__ = (int *)(malloc(__loop_i_16__ * sizeof(int )));
	int *__ub_j_i_16__ = (int *)(malloc(__loop_i_16__ * sizeof(int )));
	int __nlocal_12__ = __body_12__;
	int __nlocal_13__ = __body_13__;
	int __nlocal_14__ = __body_14__;
	__body_0__ = 0;
	__body_1__ = 0;
	__loop_i_6__ = 0;
	__body_i_6__ = 0;
	__body_2__ = 0;
	__body_3__ = 0;
	__body_4__ = 0;
	__body_5__ = 0;
	__body_6__ = 0;
	__loop_i_11__ = 0;
	__body_i_11__ = 0;
	__body_7__ = 0;
	__body_8__ = 0;
	__body_9__ = 0;
	__body_10__ = 0;
	__body_11__ = 0;
	__loop_i_16__ = 0;
	__body_i_16__ = 0;
	__body_12__ = 0;
	__body_13__ = 0;
	__body_14__ = 0;

	// Loop 0
	if ((myTeam == 0) || (myTeam == 1)){

		for (i = 0; i < ARCHnodes; i++) {

			if (get_vertex_home(0,i) == __myid__){
				__body_0__ = __body_0__ + 1;
			}
		}
	}

	// Loop 1
	if ((myTeam == 0) || (myTeam == 1) || (myTeam == 2)){

		for (i = 0; i < ARCHnodes; i++) {

			if (get_vertex_home(0,i) == __myid__) {{
					Anext = get_elem(1,i);
					__i_K_i_1_[__body_1__] = Anext;
					__lb_j_i_6__[__loop_i_6__] = (get_elem(1,i) + 1);
					__ub_j_i_6__[__loop_i_6__] = get_elem(1,i + 1);
					for (j = (get_elem(1,i) + 1);
					     j < get_elem(1,i + 1);
					     j++) {

						col = get_elem(0,j);
						if (j == (get_elem(1,i) + 1))
							__o_K_j_3_[__loop_i_6__] = j;

						__i_disp1_j_4_[__body_i_6__] = col;
						__i_disp0_j_5_[__body_i_6__] = col;;

						__body_i_6__ = __body_i_6__ + 1;;
					}
					__loop_i_6__ = __loop_i_6__ + 1;;
				}
				__body_1__ = __body_1__ + 1;;
			}
		}
	}

	// Loop 2
	if ((myTeam == 1) || (myTeam == 2) || (myTeam == 3)){

		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __myid__) {
				__body_2__ = __body_2__ + 1;;
			}
		}
	}

	// Loop 3
	if ((myTeam == 2) || (myTeam == 3) || (myTeam == 4) || (myTeam == 6) ||
	    (myTeam == 7) || (myTeam == 12) || (myTeam == 14)){

		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __myid__) {
				__body_3__ = __body_3__ + 1;;
			}
		}
	}

	// Loop 4
	if ((myTeam == 3) || (myTeam == 4) || (myTeam == 5)){

		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __myid__) {
				__body_4__ = __body_4__ + 1;;
			}
		}
	}

	// Loop 5
	if ((myTeam == 4) || (myTeam == 5) || (myTeam == 6)){

		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __myid__) {
				__body_5__ = __body_5__ + 1;;
			}
		}
	}

	// Loop 6
	if ((myTeam == 3) || (myTeam == 5) || (myTeam == 6) || (myTeam == 7)){

		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __myid__) {{
					Anext = get_elem(1,i);
					__i_K_i_22_[__body_6__] = Anext;
					__lb_j_i_11__[__loop_i_11__] = (get_elem(1,i) + 1);
					__ub_j_i_11__[__loop_i_11__] = get_elem(1,i + 1);
					for (j = (get_elem(1,i) + 1); j < get_elem(1,i + 1); j++) {{
							col = get_elem(0,j);
							if (j == (get_elem(1,i) + 1))
								__o_K_j_24_[__loop_i_11__] = j;
							__i_disp0_j_25_[__body_i_11__] = col;
							__i_disp2_j_26_[__body_i_11__] = col;;
						}
						__body_i_11__ = __body_i_11__ + 1;;
					}
					__loop_i_11__ = __loop_i_11__ + 1;;
				}
				__body_6__ = __body_6__ + 1;;
			}
		}
	}

	// Loop 7
	if ((myTeam == 3) || (myTeam == 6) || (myTeam == 7) || (myTeam == 8)){

		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __myid__) {
				__body_7__ = __body_7__ + 1;;
			}
		}
	}

	// Loop 8
	if ((myTeam == 7) || (myTeam == 8) || (myTeam == 9) || (myTeam == 11) ||
	    (myTeam == 12)){

		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __myid__) {
				__body_8__ = __body_8__ + 1;;
			}
		}
	}

	// Loop 9
	if ((myTeam == 8) || (myTeam == 9) || (myTeam == 10)){

		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __myid__) {
				__body_9__ = __body_9__ + 1;;
			}
		}
	}

	// Loop 10
	if ((myTeam == 9) || (myTeam == 10) || (myTeam == 11)){

		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __myid__) {
				__body_10__ = __body_10__ + 1;;
			}
		}
	}

	// Loop 11
	if ((myTeam == 8) || (myTeam == 10) || (myTeam == 11) || (myTeam == 12)){

		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __myid__) {{
					Anext = get_elem(1,i);
					__i_K_i_43_[__body_11__] = Anext;
					__lb_j_i_16__[__loop_i_16__] = (get_elem(1,i) + 1);
					__ub_j_i_16__[__loop_i_16__] = get_elem(1,i + 1);
					for (j = (get_elem(1,i) + 1); j < get_elem(1,i + 1); j++) {{
							col = get_elem(0,j);
							if (j == (get_elem(1,i) + 1))
								__o_K_j_45_[__loop_i_16__] = j;
							__i_disp2_j_46_[__body_i_16__] = col;
							__i_disp1_j_47_[__body_i_16__] = col;;
						}
						__body_i_16__ = __body_i_16__ + 1;;
					}
					__loop_i_16__ = __loop_i_16__ + 1;;
				}
				__body_11__ = __body_11__ + 1;;
			}
		}
	}

	// Loop 12
	if ((myTeam == 3) || (myTeam == 8) || (myTeam == 11) || (myTeam == 12) ||
	    (myTeam == 13)){

		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __myid__) {
				__body_12__ = __body_12__ + 1;;
			}
		}
	}

	// Loop 13
	if ((myTeam == 12) || (myTeam == 13) || (myTeam == 14)){

		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __myid__) {
				__body_13__ = __body_13__ + 1;;
			}
		}
	}

	// Loop 14
	if ((myTeam == 3) || (myTeam == 13) || (myTeam == 14)){

		for (i = 0; i < ARCHnodes; i++) {
			if (get_vertex_home(0,i) == __myid__) {
				__body_14__ = __body_14__ + 1;;
			}
		}
	}

	// Initialize M
	double **__local_M__ = NULL;
	if ((myTeam == 2) || (myTeam == 3) || (myTeam == 7) || (myTeam == 8) ||
	    (myTeam == 12) || (myTeam == 13)){

		int __localsize_M__ = get_local_size(0);
		__local_M__ = malloc_2d_double(__localsize_M__, 3);
		populate_local_array(0, __local_M__[0], M[0], 3);
	}

	// Initialize C
	double **__local_C__ = NULL;
	if ((myTeam == 2) || (myTeam == 3) || (myTeam == 7) || (myTeam == 8) ||
	    (myTeam == 12) || (myTeam == 13)){

		int __localsize_C__ = get_local_size(1);
		__local_C__ = malloc_2d_double(__localsize_C__, 3 );
		populate_local_array(1,__local_C__[0],C[0], 3 );
	}

	// Initialize M23
	double **__local_M23__ = NULL;
	if ((myTeam == 2) || (myTeam == 7) || (myTeam == 12)){

		int __localsize_M23__ = get_local_size(2);
		__local_M23__ = malloc_2d_double(__localsize_M23__, 3 );
		populate_local_array(2,__local_M23__[0],M23[0], 3 );
	}

	// Initialize C23
	double **__local_C23__ = NULL;
	if ((myTeam == 2) || (myTeam == 7) || (myTeam == 12)){

		int __localsize_C23__ = get_local_size(3);
		__local_C23__ = malloc_2d_double(__localsize_C23__, 3 );
		populate_local_array(3,__local_C23__[0],C23[0], 3 );
	}

	// Initialize V23
	double **__local_V23__ = NULL;
	if ((myTeam == 2) || (myTeam == 7) || (myTeam == 12)){

		int __localsize_V23__ = get_local_size(4);
		__local_V23__ = malloc_2d_double(__localsize_V23__, 3 );
		populate_local_array(4,__local_V23__[0],V23[0], 3 );
	}

	// Initialize vel
	double **__local_vel__ = NULL;
	if ((myTeam == 4) || (myTeam == 9) || (myTeam == 14)){

		int __localsize_vel__ = get_local_size(5);
		__local_vel__ = malloc_2d_double(__localsize_vel__, 3);
		populate_local_array(5, __local_vel__[0], vel[0], 3);
	}

	// Initialize disp0
	double **__local_disp0__ = NULL;
	if ((myTeam == 0) || (myTeam == 1) || (myTeam == 2) || (myTeam == 3) ||
	    (myTeam == 4) || (myTeam == 6) || (myTeam == 7) || (myTeam == 12) ||
	    (myTeam == 14)){

		int __localsize_disp0__ = get_local_size(6);
		__local_disp0__ = malloc_2d_double(__localsize_disp0__, 3 );
		populate_local_array(6,__local_disp0__[0],disp0[0], 3 );
		renumber_access_array(6,__body_i_6__,__i_disp0_j_5_);
		renumber_access_array(6,__body_i_11__,__i_disp0_j_25_);
		communicate_writes_for(6);
		communicate_reads_for(6);
	}

	// Initialize disp1
	double **__local_disp1__ = NULL;
	if ((myTeam == 1) || (myTeam == 2) || (myTeam == 7) || (myTeam == 9) ||
	    (myTeam == 10) || (myTeam == 11) || (myTeam == 12) || (myTeam == 13) ||
	    (myTeam == 14)){

		int __localsize_disp1__ = get_local_size(7);
		__local_disp1__ = malloc_2d_double(__localsize_disp1__, 3 );
		populate_local_array(7,__local_disp1__[0],disp1[0], 3 );
		renumber_access_array(7,__body_i_6__,__i_disp1_j_4_);
		renumber_access_array(7,__body_i_16__,__i_disp1_j_47_);
		communicate_writes_for(7);
		communicate_reads_for(7);
	}

	// Initialize disp2
	double **__local_disp2__ = NULL;
	if ((myTeam == 2) || (myTeam == 4) || (myTeam == 5) || (myTeam == 6) ||
	    (myTeam == 7) || (myTeam == 8) || (myTeam == 9) || (myTeam == 11) ||
	    (myTeam == 12)){

		int __localsize_disp2__ = get_local_size(8);
		__local_disp2__ = malloc_2d_double(__localsize_disp2__, 3 );
		populate_local_array(8,__local_disp2__[0],disp2[0], 3 );
		renumber_access_array(8,__body_i_11__,__i_disp2_j_26_);
		renumber_access_array(8,__body_i_16__,__i_disp2_j_46_);
		communicate_writes_for(8);
		communicate_reads_for(8);
	}

	// Initialize K
	double **__local_K__ = NULL;
	if ((myTeam == 1) || (myTeam == 6) || (myTeam == 11)){

		int __localsize_K__ = get_local_size(9);
		__local_K__ = malloc_2d_double(__localsize_K__, 9 );
		populate_local_array(9,__local_K__[0],K[0], 9 );
		renumber_access_array(9,__body_1__,__i_K_i_1_);
		renumber_offset_array(9,__loop_i_6__,__o_K_j_3_,__lb_j_i_6__);
		renumber_access_array(9,__body_6__,__i_K_i_22_);
		renumber_offset_array(9,__loop_i_11__,__o_K_j_24_,__lb_j_i_11__);
		renumber_access_array(9,__body_11__,__i_K_i_43_);
		renumber_offset_array(9,__loop_i_16__,__o_K_j_45_,__lb_j_i_16__);
	}

	/*
	 * EXECUTOR
	 */

	setup_executor();;;

	for (iter = 1; iter <= timesteps; ) {

		if (myTeam == 0){

			/*
			 * LOOP 0
			 */
			__body_0__ = 0;
			for (i = 0; i < __nlocal_0__; ++i) {

				// No need to communicate ghosts to team, only data to consumers

				for (j = 0; j < 3; j++) {
					__local_disp0__[i][j] = 0.0;;
				};

				pipe_send(i);
			}
		}

		if (myTeam == 1){

			/*
			 * LOOP 1
			 */
			__body_1__ = 0;
			__loop_i_6__ = 0;
			__body_i_6__ = 0;
			/* communicate_reads(1); */
			init_write_ghosts(1);
			for (i = 0; i < __nlocal_1__; ++i) {

				pipe_receive(i);

				sum0 =
					(((__local_K__[__i_K_i_1_[i]][0] * __local_disp1__[i][0]) +
					  (__local_K__[__i_K_i_1_[i]][1] * __local_disp1__[i][1])) +
					 (__local_K__[__i_K_i_1_[i]][2] * __local_disp1__[i][2]));

				sum1 =
					(((__local_K__[__i_K_i_1_[i]][3] * __local_disp1__[i][0]) +
					  (__local_K__[__i_K_i_1_[i]][4] * __local_disp1__[i][1])) +
					 (__local_K__[__i_K_i_1_[i]][5] * __local_disp1__[i][2]));

				sum2 =
					(((__local_K__[__i_K_i_1_[i]][6] * __local_disp1__[i][0]) +
					  (__local_K__[__i_K_i_1_[i]][7] * __local_disp1__[i][1])) +
					 (__local_K__[__i_K_i_1_[i]][8] * __local_disp1__[i][2]));

				__o_K_j_3__offset = __o_K_j_3_[__loop_i_6__];

				for (j = __lb_j_i_6__[__loop_i_6__];
				     j < __ub_j_i_6__[__loop_i_6__]; ++j) {

					sum0 +=
						(((__local_K__[__o_K_j_3__offset + j][0] *
						   __local_disp1__[__i_disp1_j_4_[__body_i_6__]][0]) +
						  (__local_K__[__o_K_j_3__offset + j][1] *
						   __local_disp1__[__i_disp1_j_4_[__body_i_6__]][1])) +
						 (__local_K__[__o_K_j_3__offset + j][2] *
						  __local_disp1__[__i_disp1_j_4_[__body_i_6__]][2]));

					sum1 +=
						(((__local_K__[__o_K_j_3__offset + j][3] *
						   __local_disp1__[__i_disp1_j_4_[__body_i_6__]][0]) +
						  (__local_K__[__o_K_j_3__offset + j][4] *
						   __local_disp1__[__i_disp1_j_4_[__body_i_6__]][1])) +
						 (__local_K__[__o_K_j_3__offset + j][5] *
						  __local_disp1__[__i_disp1_j_4_[__body_i_6__]][2]));

					sum2 +=
						(((__local_K__[__o_K_j_3__offset + j][6] *
						   __local_disp1__[__i_disp1_j_4_[__body_i_6__]][0]) +
						  (__local_K__[__o_K_j_3__offset + j][7] *
						   __local_disp1__[__i_disp1_j_4_[__body_i_6__]][1])) +
						 (__local_K__[__o_K_j_3__offset + j][8] *
						  __local_disp1__[__i_disp1_j_4_[__body_i_6__]][2]));

					__local_disp0__[__i_disp0_j_5_[__body_i_6__]][0] +=
						(((__local_K__[__o_K_j_3__offset + j][0] *
						   __local_disp1__[i][0]) +
						  (__local_K__[__o_K_j_3__offset + j][3] *
						   __local_disp1__[i][1])) +
						 (__local_K__[__o_K_j_3__offset + j][6] *
						  __local_disp1__[i][2]));

					__local_disp0__[__i_disp0_j_5_[__body_i_6__]][1] +=
						(((__local_K__[__o_K_j_3__offset + j][1] *
						   __local_disp1__[i][0]) +
						  (__local_K__[__o_K_j_3__offset + j][4] *
						   __local_disp1__[i][1])) +
						 (__local_K__[__o_K_j_3__offset + j][7] *
						  __local_disp1__[i][2]));

					__local_disp0__[__i_disp0_j_5_[__body_i_6__]][2] +=
						(((__local_K__[__o_K_j_3__offset + j][2] *
						   __local_disp1__[i][0]) +
						  (__local_K__[__o_K_j_3__offset + j][5] *
						   __local_disp1__[i][1])) +
						 (__local_K__[__o_K_j_3__offset + j][8] *
						  __local_disp1__[i][2]));

					__body_i_6__ = __body_i_6__ + 1;;
				}
				__loop_i_6__ = __loop_i_6__ + 1;
				__local_disp0__[i][0] += sum0;
				__local_disp0__[i][1] += sum1;
				__local_disp0__[i][2] += sum2;;

				pipe_send(i);
			}
			/* communicate_writes(1); */
		}
		time = (iter * Exc_dt);

		if (myTeam == 2){

			/*
			 * LOOP 2
			 */
			__body_2__ = 0;
			for (i = 0; i < __nlocal_2__; ++i) {

				pipe_receive(i);

				for (j = 0; j < 3; j++) {
					__local_disp0__[i][j] =
						(((((-__local_disp0__[i][j] * Exc_dt) * Exc_dt) +
						   ((2.0 * __local_M__[i][j]) *
						    __local_disp1__[i][j])) -
						  ((__local_M__[i][j] -
						    ((Exc_dt / 2.0) * __local_C__[i][j])) *
						   __local_disp2__[i][j])) -
						 ((Exc_dt * Exc_dt) *
						  ((((__local_M23__[i][j] * phi2(time,Exc_t0)) / 2.0) +
						    ((__local_C23__[i][j] * phi1(time,Exc_t0)) / 2.0)) +
						   ((__local_V23__[i][j] * phi0(time,Exc_t0)) / 2.0))));
				};

				pipe_send(i);
			}

		}

		if (myTeam == 3){

			/*
			 * LOOP 3
			 */
			__body_3__ = 0;
			for (i = 0; i < __nlocal_3__; ++i) {

				pipe_receive(i);

				for (j = 0; j < 3; j++) {
					__local_disp0__[i][j] =
						(__local_disp0__[i][j] /
						 (__local_M__[i][j] +
						  ((Exc_dt / 2.0) * __local_C__[i][j])));

				};

				pipe_send(i);
			}
		}

		if (myTeam == 4){

			/*
			 * LOOP 4
			 */
			__body_4__ = 0;
			for (i = 0; i < __nlocal_4__; ++i) {

				pipe_receive(i);

				for (j = 0; j < 3; j++) {
					__local_vel__[i][j] =
						((0.5 / Exc_dt) *
						 (__local_disp0__[i][j] - __local_disp2__[i][j]));;
				};

				pipe_send(i);
			}
		}
		iter += 1;
		/* Print out the response at the source and epicenter nodes */

		if (myTeam == 5){

			/*
			 * LOOP 5
			 */
			__body_5__ = 0;
			for (i = 0; i < __nlocal_5__; ++i) {

				pipe_receive(i);

				for (j = 0; j < 3; j++) {
					__local_disp2__[i][j] = 0.0;;
				};

				pipe_send(i);
			}
		}

		if (myTeam == 6){

			/*
			 * LOOP 6
			 */
			__body_6__ = 0;
			__loop_i_11__ = 0;
			__body_i_11__ = 0;
			/* communicate_reads(6); */
			init_write_ghosts(6);
			for (i = 0; i < __nlocal_6__; ++i) {

				pipe_receive(i);

				sum0 =
					(((__local_K__[__i_K_i_22_[i]][0] * __local_disp0__[i][0]) +
					  (__local_K__[__i_K_i_22_[i]][1] *
					   __local_disp0__[i][1])) +
					 (__local_K__[__i_K_i_22_[i]][2] * __local_disp0__[i][2]));
				sum1 =
					(((__local_K__[__i_K_i_22_[i]][3] * __local_disp0__[i][0]) +
					  (__local_K__[__i_K_i_22_[i]][4] *
					   __local_disp0__[i][1])) +
					 (__local_K__[__i_K_i_22_[i]][5] * __local_disp0__[i][2]));
				sum2 =
					(((__local_K__[__i_K_i_22_[i]][6] * __local_disp0__[i][0]) +
					  (__local_K__[__i_K_i_22_[i]][7] *
					   __local_disp0__[i][1])) +
					 (__local_K__[__i_K_i_22_[i]][8] * __local_disp0__[i][2]));
				__o_K_j_24__offset = __o_K_j_24_[__loop_i_11__];

				for (j = __lb_j_i_11__[__loop_i_11__];
				     j < __ub_j_i_11__[__loop_i_11__];
				     ++j) {

					sum0 +=
						(((__local_K__[__o_K_j_24__offset + j][0] *
						   __local_disp0__[__i_disp0_j_25_[__body_i_11__]][0]) +
						  (__local_K__[__o_K_j_24__offset + j][1] *
						   __local_disp0__[__i_disp0_j_25_[__body_i_11__]][1])) +
						 (__local_K__[__o_K_j_24__offset + j][2] *
						  __local_disp0__[__i_disp0_j_25_[__body_i_11__]][2]));
					sum1 +=
						(((__local_K__[__o_K_j_24__offset + j][3] *
						   __local_disp0__[__i_disp0_j_25_[__body_i_11__]][0]) +
						  (__local_K__[__o_K_j_24__offset + j][4] *
						   __local_disp0__[__i_disp0_j_25_[__body_i_11__]][1])) +
						 (__local_K__[__o_K_j_24__offset + j][5] *
						  __local_disp0__[__i_disp0_j_25_[__body_i_11__]][2]));
					sum2 +=
						(((__local_K__[__o_K_j_24__offset + j][6] *
						   __local_disp0__[__i_disp0_j_25_[__body_i_11__]][0]) +
						  (__local_K__[__o_K_j_24__offset + j][7] *
						   __local_disp0__[__i_disp0_j_25_[__body_i_11__]][1])) +
						 (__local_K__[__o_K_j_24__offset + j][8] *
						  __local_disp0__[__i_disp0_j_25_[__body_i_11__]][2]));
					__local_disp2__[__i_disp2_j_26_[__body_i_11__]][0] +=
						(((__local_K__[__o_K_j_24__offset + j][0] *
						   __local_disp0__[i][0]) +
						  (__local_K__[__o_K_j_24__offset + j][3] *
						   __local_disp0__[i][1])) +
						 (__local_K__[__o_K_j_24__offset + j][6] *
						  __local_disp0__[i][2]));
					__local_disp2__[__i_disp2_j_26_[__body_i_11__]][1] +=
						(((__local_K__[__o_K_j_24__offset + j][1] *
						   __local_disp0__[i][0]) +
						  (__local_K__[__o_K_j_24__offset + j][4] *
						   __local_disp0__[i][1])) +
						 (__local_K__[__o_K_j_24__offset + j][7] *
						  __local_disp0__[i][2]));
					__local_disp2__[__i_disp2_j_26_[__body_i_11__]][2] +=
						(((__local_K__[__o_K_j_24__offset + j][2] *
						   __local_disp0__[i][0]) +
						  (__local_K__[__o_K_j_24__offset + j][5] *
						   __local_disp0__[i][1])) +
						 (__local_K__[__o_K_j_24__offset + j][8] *
						  __local_disp0__[i][2]));
					__body_i_11__ = __body_i_11__ + 1;;

				}

				__loop_i_11__ = __loop_i_11__ + 1;
				__local_disp2__[i][0] += sum0;
				__local_disp2__[i][1] += sum1;
				__local_disp2__[i][2] += sum2;;

				pipe_send(i);
			}
			/* communicate_writes(6); */
		}

		time = (iter * Exc_dt);

		if (myTeam == 7){

			/*
			 * LOOP 7
			 */
			__body_7__ = 0;
			for (i = 0; i < __nlocal_7__; ++i) {

				pipe_receive(i);

				for (j = 0; j < 3; j++) {
					__local_disp2__[i][j] =
						(((((-__local_disp2__[i][j] * Exc_dt) * Exc_dt) +
						   ((2.0 * __local_M__[i][j]) *
						    __local_disp0__[i][j])) -
						  ((__local_M__[i][j] -
						    ((Exc_dt / 2.0) * __local_C__[i][j])) *
						   __local_disp1__[i][j])) -
						 ((Exc_dt * Exc_dt) *
						  ((((__local_M23__[i][j] * phi2(time,Exc_t0)) / 2.0) +
						    ((__local_C23__[i][j] * phi1(time,Exc_t0)) / 2.0)) +
						   ((__local_V23__[i][j] * phi0(time,Exc_t0)) / 2.0))));
				};

				pipe_send(i);
			}
		}

		if (myTeam == 8){

			/*
			 * LOOP 8
			 */
			__body_8__ = 0;
			for (i = 0; i < __nlocal_8__; ++i) {

				pipe_receive(i);

				for (j = 0; j < 3; j++) {
					__local_disp2__[i][j] =
						(__local_disp2__[i][j] /
						 (__local_M__[i][j] + ((Exc_dt / 2.0) *
						                       __local_C__[i][j])));
				};

				pipe_send(i);
			}
		}

		if (myTeam == 9){

			/*
			 * LOOP 9
			 */
			__body_9__ = 0;
			for (i = 0; i < __nlocal_9__; ++i) {

				pipe_receive(i);

				for (j = 0; j < 3; j++) {
					__local_vel__[i][j] =
						((0.5 / Exc_dt) *
						 (__local_disp2__[i][j] - __local_disp1__[i][j]));;
				};

				pipe_send(i);
			}
		}
		iter += 1;

		if (myTeam == 10){

			/*
			 * LOOP 10
			 */
			__body_10__ = 0;
			for (i = 0; i < __nlocal_10__; ++i) {

				pipe_receive(i);

				for (j = 0; j < 3; j++) {
					__local_disp1__[i][j] = 0.0;;
				};

				pipe_send(i);
			}
		}

		if (myTeam == 11){

			/*
			 * LOOP 11
			 */
			__body_11__ = 0;
			__loop_i_16__ = 0;
			__body_i_16__ = 0;
			/* communicate_reads(11); */
			init_write_ghosts(11);
			for (i = 0; i < __nlocal_11__; ++i) {

				pipe_receive(i);

				sum0 =
					(((__local_K__[__i_K_i_43_[i]][0] * __local_disp2__[i][0]) +
					  (__local_K__[__i_K_i_43_[i]][1] * __local_disp2__[i][1])) +
					 (__local_K__[__i_K_i_43_[i]][2] * __local_disp2__[i][2]));
				sum1 =
					(((__local_K__[__i_K_i_43_[i]][3] * __local_disp2__[i][0]) +
					  (__local_K__[__i_K_i_43_[i]][4] * __local_disp2__[i][1])) +
					 (__local_K__[__i_K_i_43_[i]][5] * __local_disp2__[i][2]));
				sum2 =
					(((__local_K__[__i_K_i_43_[i]][6] * __local_disp2__[i][0]) +
					  (__local_K__[__i_K_i_43_[i]][7] * __local_disp2__[i][1])) +
					 (__local_K__[__i_K_i_43_[i]][8] * __local_disp2__[i][2]));
				__o_K_j_45__offset = __o_K_j_45_[__loop_i_16__];

				for (j = __lb_j_i_16__[__loop_i_16__];
				     j < __ub_j_i_16__[__loop_i_16__];
				     ++j) {

					sum0 +=
						(((__local_K__[__o_K_j_45__offset + j][0] *
						   __local_disp2__[__i_disp2_j_46_[__body_i_16__]][0]) +
						  (__local_K__[__o_K_j_45__offset + j][1] *
						   __local_disp2__[__i_disp2_j_46_[__body_i_16__]][1])) +
						 (__local_K__[__o_K_j_45__offset + j][2] *
						  __local_disp2__[__i_disp2_j_46_[__body_i_16__]][2]));
					sum1 +=
						(((__local_K__[__o_K_j_45__offset + j][3] *
						   __local_disp2__[__i_disp2_j_46_[__body_i_16__]][0]) +
						  (__local_K__[__o_K_j_45__offset + j][4] *
						   __local_disp2__[__i_disp2_j_46_[__body_i_16__]][1])) +
						 (__local_K__[__o_K_j_45__offset + j][5] *
						  __local_disp2__[__i_disp2_j_46_[__body_i_16__]][2]));
					sum2 +=
						(((__local_K__[__o_K_j_45__offset + j][6] *
						   __local_disp2__[__i_disp2_j_46_[__body_i_16__]][0]) +
						  (__local_K__[__o_K_j_45__offset + j][7] *
						   __local_disp2__[__i_disp2_j_46_[__body_i_16__]][1])) +
						 (__local_K__[__o_K_j_45__offset + j][8] *
						  __local_disp2__[__i_disp2_j_46_[__body_i_16__]][2]));
					__local_disp1__[__i_disp1_j_47_[__body_i_16__]][0] +=
						(((__local_K__[__o_K_j_45__offset + j][0] *
						   __local_disp2__[i][0]) +
						  (__local_K__[__o_K_j_45__offset + j][3] *
						   __local_disp2__[i][1])) +
						 (__local_K__[__o_K_j_45__offset + j][6] *
						  __local_disp2__[i][2]));
					__local_disp1__[__i_disp1_j_47_[__body_i_16__]][1] +=
						(((__local_K__[__o_K_j_45__offset + j][1] *
						   __local_disp2__[i][0]) +
						  (__local_K__[__o_K_j_45__offset + j][4] *
						   __local_disp2__[i][1])) +
						 (__local_K__[__o_K_j_45__offset + j][7] *
						  __local_disp2__[i][2]));
					__local_disp1__[__i_disp1_j_47_[__body_i_16__]][2] +=
						(((__local_K__[__o_K_j_45__offset + j][2] *
						   __local_disp2__[i][0]) +
						  (__local_K__[__o_K_j_45__offset + j][5] *
						   __local_disp2__[i][1])) +
						 (__local_K__[__o_K_j_45__offset + j][8] *
						  __local_disp2__[i][2]));
					__body_i_16__ = __body_i_16__ + 1;;
				}
				__loop_i_16__ = __loop_i_16__ + 1;
				__local_disp1__[i][0] += sum0;
				__local_disp1__[i][1] += sum1;
				__local_disp1__[i][2] += sum2;;

				pipe_send(i);
			}
			/* communicate_writes(11); */
		}

		time = (iter * Exc_dt);

		if (myTeam == 12){

			/*
			 * LOOP 12
			 */
			__body_12__ = 0;
			for (i = 0; i < __nlocal_12__; ++i) {

				pipe_receive(i);

				for (j = 0; j < 3; j++) {
					__local_disp1__[i][j] =
						(((((-__local_disp1__[i][j] * Exc_dt) * Exc_dt) +
						   ((2.0 * __local_M__[i][j]) *
						    __local_disp2__[i][j])) -
						  ((__local_M__[i][j] -
						    ((Exc_dt / 2.0) * __local_C__[i][j])) *
						   __local_disp0__[i][j])) -
						 ((Exc_dt * Exc_dt) *
						  ((((__local_M23__[i][j] * phi2(time,Exc_t0)) / 2.0) +
						    ((__local_C23__[i][j] * phi1(time,Exc_t0)) / 2.0)) +
						   ((__local_V23__[i][j] * phi0(time,Exc_t0)) / 2.0))));
				};

				pipe_send(i);
			}
		}

		if (myTeam == 13){

			/*
			 * LOOP 13
			 */
			__body_13__ = 0;
			for (i = 0; i < __nlocal_13__; ++i) {

				pipe_receive(i);

				for (j = 0; j < 3; j++) {
					__local_disp1__[i][j] =
						(__local_disp1__[i][j] /
						 (__local_M__[i][j] +
						  ((Exc_dt / 2.0) * __local_C__[i][j])));;
				};

				pipe_send(i);
			}
		}

		if (myTeam == 14){

			/*
			 * LOOP 14
			 */
			__body_14__ = 0;
			for (i = 0; i < __nlocal_14__; ++i) {

				pipe_receive(i);

				for (j = 0; j < 3; j++) {
					__local_vel__[i][j] =
						((0.5 / Exc_dt) *
						 (__local_disp1__[i][j] - __local_disp0__[i][j]));;
				};
			}
		}

		pipe_endExternalIter();
		iter += 1;
	}

	populate_global_arrays();

	free_2d_double(__local_M__);
	free_2d_double(__local_C__);
	free_2d_double(__local_M23__);
	free_2d_double(__local_C23__);
	free_2d_double(__local_V23__);
	free_2d_double(__local_vel__);
	free(__i_disp0_j_5_);
	free(__i_disp0_j_25_);
	free_2d_double(__local_disp0__);
	free(__i_disp1_j_4_);
	free(__i_disp1_j_47_);
	free_2d_double(__local_disp1__);
	free(__i_disp2_j_26_);
	free(__i_disp2_j_46_);
	free_2d_double(__local_disp2__);
	free(__i_K_i_1_);
	free(__o_K_j_3_);
	free(__i_K_i_22_);
	free(__o_K_j_24_);
	free(__i_K_i_43_);
	free(__o_K_j_45_);
	free_2d_double(__local_K__);
	free(__lb_j_i_6__);
	free(__ub_j_i_6__);
	free(__lb_j_i_11__);
	free(__ub_j_i_11__);
	free(__lb_j_i_16__);
	free(__ub_j_i_16__);
	delete_inspector();;

	fprintf(stderr,"Time step %d\n",iter);
	if (Src.sourcenode <= ARCHmine)
		printf("%d: %.2e %.2e %.2e\n",
		       ARCHglobalnode[Src.sourcenode], disp0[Src.sourcenode][0],
		       disp0[Src.sourcenode][1],disp0[Src.sourcenode][2]);
	if (Src.epicenternode <= ARCHmine)
		printf("%d: %.2e %.2e %.2e\n",
		       ARCHglobalnode[Src.epicenternode], disp0[Src.epicenternode][0],
		       disp0[Src.epicenternode][1],disp0[Src.epicenternode][2]);
	fprintf(stderr, "%s: %d nodes %d elems %d timesteps\n",
	        progname, ARCHglobalnodes, ARCHglobalelems, timesteps);
	fprintf(stderr,"\n");
	fflush(stderr);
	if (!(options.quiet != 0)) {
		fprintf(stderr,"%s: Done. Terminating the simulation.\n",progname);
	}

	ARMCI_Finalize();
	MPI_Finalize();
	return 0;
}
/* --------------------------------------------------------------------------*/
/* --------------------------------------------------------------------------*/
/* Compute shape function derivatives                                        */
/* N_1 = 1 - r - s - t                                                       */
/* N_2 = r                                                                   */
/* N_3 = s                                                                   */
/* N_4 = t                                                                   */

void shape_ders(ds)
     double (*ds)[4UL];
{
	ds[0][0] = (-1);
	ds[1][0] = (-1);
	ds[2][0] = (-1);
	ds[0][1] = 1;
	ds[1][1] = 0;
	ds[2][1] = 0;
	ds[0][2] = 0;
	ds[1][2] = 1;
	ds[2][2] = 0;
	ds[0][3] = 0;
	ds[1][3] = 0;
	ds[2][3] = 1;
}
/* --------------------------------------------------------------------------*/
/* Calculate Young's modulus E and Poisson's ratio nu,                       */
/* given a pair of compressional (cp) and shear (cs) wave velocities         */

void get_Enu(prop,E,nu)
     struct properties *prop;
     double *E;
     double *nu;
{
	double ratio;
	ratio = ((prop -> cp) / (prop -> cs));
	ratio = (ratio * ratio);
	*nu = ((0.5 * (ratio - 2.0)) / (ratio - 1.0));
	*E = ((((2.0 * (prop -> den)) * (prop -> cs)) * (prop -> cs)) * (1.0 +  *nu));
}
/* --------------------------------------------------------------------------*/
/* --------------------------------------------------------------------------*/
/* Calculate the inverse and the determinant of the Jacobian,                */
/* given the Jacobian                                                        */
/* (a on input holds the Jacobian and on output its inverse                  */

void inv_J(a,det)
     double (*a)[3UL];
     double *det;
{
	double d1;
	double c[3UL][3UL];
	int i;
	int j;
	{
		c[0][0] = ((a[1][1] * a[2][2]) - (a[2][1] * a[1][2]));
		c[0][1] = ((a[0][2] * a[2][1]) - (a[0][1] * a[2][2]));
		c[0][2] = ((a[0][1] * a[1][2]) - (a[0][2] * a[1][1]));
		c[1][0] = ((a[1][2] * a[2][0]) - (a[1][0] * a[2][2]));
		c[1][1] = ((a[0][0] * a[2][2]) - (a[0][2] * a[2][0]));
		c[1][2] = ((a[0][2] * a[1][0]) - (a[0][0] * a[1][2]));
		c[2][0] = ((a[1][0] * a[2][1]) - (a[1][1] * a[2][0]));
		c[2][1] = ((a[0][1] * a[2][0]) - (a[0][0] * a[2][1]));
		c[2][2] = ((a[0][0] * a[1][1]) - (a[0][1] * a[1][0]));
	}
	*det = (((a[0][0] * c[0][0]) + (a[0][1] * c[1][0])) + (a[0][2] * c[2][0]));
	d1 = (1.0 /  *det);
	{
		for (i = 0; i < 3; i++) 
			for (j = 0; j < 3; j++) 
				a[i][j] = (c[i][j] * d1);
	}
}
/* --------------------------------------------------------------------------*/
/* --------------------------------------------------------------------------*/
/* Calculate the element stiffness (Ke[12][12]) and                          */
/*           the element mass matrices (Me[12]),                             */
/* given the four vertices of a tetrahedron                                  */

void element_matrices(vertices,prop,Ke,Me)
     double (*vertices)[3UL];
     struct properties *prop;
     double (*Ke)[12UL];
     double *Me;
{
	double ds[3UL][4UL];
	double sum[3UL];
	double jacobian[3UL][3UL];
	double det;
	double volume;
	double E;
	double nu;
	double c1;
	double c2;
	double c3;
	double tt;
	double ts;
	int i;
	int j;
	int m;
	int n;
	int row;
	int column;
	shape_ders(ds);
	{
		for (i = 0; i < 3; i++) 
			for (j = 0; j < 3; j++) {
				sum[0] = 0.0;
				for (m = 0; m < 4; m++) 
					sum[0] = (sum[0] + (ds[i][m] * vertices[m][j]));
				/* compute Jacobian */
				jacobian[j][i] = sum[0];
			}
	}
	/* compute J^-1 & its determinant */
	inv_J(jacobian,&det);
	{
		for (m = 0; m < 4; m++) {
			for (i = 0; i < 3; i++) {
				sum[i] = 0.0;
				for (j = 0; j < 3; j++) 
					sum[i] = (sum[i] + (jacobian[j][i] * ds[j][m]));
			}
			for (i = 0; i < 3; i++) 
				ds[i][m] = sum[i];
		}
		volume = (det / 6.0);
	}
	if (volume <= 0) {
		fprintf(stderr,"Warning: Element volume = %f !\n",volume);
	}
	get_Enu(prop,&E,&nu);
	{
		c1 = ((E / ((2.0 * (nu + 1.0)) * (1.0 - (nu * 2.0)))) * volume);
		c2 = (((E * nu) / ((nu + 1.0) * (1.0 - (nu * 2.0)))) * volume);
		c3 = ((E / ((nu + 1.0) * 2.0)) * volume);
		row = -1;
	}
	/* lower triangular stiffness matrix */
	for (m = 0; m < 4; m++) {
		for (i = 0; i < 3; ++i) {{
				++row;
				column = -1;
			}
			for (n = 0; n <= m; n++) {
				for (j = 0; j < 3; j++) {
					++column;
					ts = (ds[i][m] * ds[j][n]);
					if (i == j) {
						ts = (ts * c1);
						tt = ((((ds[0][m] * ds[0][n]) + (ds[1][m] * ds[1][n])) + (ds[2][m] * ds[2][n])) * c3);
					}
					else {
						if (m == n) {
							ts = (ts * c1);
							tt = 0;
						}
						else {
							ts = (ts * c2);
							tt = ((ds[j][m] * ds[i][n]) * c3);
						}
					}
					Ke[row][column] = ((Ke[row][column] + ts) + tt);
				}
			}
		}
	}
	tt = (((prop -> den) * volume) / 4.0);
	{
		for (i = 0; i < 12; i++) 
			Me[i] = tt;
	}
	for (i = 0; i < 12; i++) 
		for (j = 0; j <= i; j++) {
			Ke[j][i] = Ke[i][j];
		}
}
/* --------------------------------------------------------------------------*/
/* --------------------------------------------------------------------------*/
/* Calculate the area of a triangle given the coordinates of                 */
/* its three vertices                                                        */

double area_triangle(vertices)
     double (*vertices)[3UL];
{
	double a;
	double b;
	double c;
	double x2;
	double y2;
	double z2;
	double p;
	double area;
	x2 = ((vertices[0][0] - vertices[1][0]) * (vertices[0][0] - vertices[1][0]));
	y2 = ((vertices[0][1] - vertices[1][1]) * (vertices[0][1] - vertices[1][1]));
	z2 = ((vertices[0][2] - vertices[1][2]) * (vertices[0][2] - vertices[1][2]));
	a = sqrt(((x2 + y2) + z2));
	x2 = ((vertices[2][0] - vertices[1][0]) * (vertices[2][0] - vertices[1][0]));
	y2 = ((vertices[2][1] - vertices[1][1]) * (vertices[2][1] - vertices[1][1]));
	z2 = ((vertices[2][2] - vertices[1][2]) * (vertices[2][2] - vertices[1][2]));
	b = sqrt(((x2 + y2) + z2));
	x2 = ((vertices[0][0] - vertices[2][0]) * (vertices[0][0] - vertices[2][0]));
	y2 = ((vertices[0][1] - vertices[2][1]) * (vertices[0][1] - vertices[2][1]));
	z2 = ((vertices[0][2] - vertices[2][2]) * (vertices[0][2] - vertices[2][2]));
	c = sqrt(((x2 + y2) + z2));
	p = (((a + b) + c) / 2.0);
	area = sqrt((((p * (p - a)) * (p - b)) * (p - c)));
	return area;
}
/* --------------------------------------------------------------------------*/
/* --------------------------------------------------------------------------*/
/* Generate the element damping matrix for the absorbing boundary            */
/* (triangular plane element)                                                */

void abe_matrix(vertices,bv,prop,Ce)
     double (*vertices)[3UL];
     int *bv;
     struct properties *prop;
     double *Ce;
{
	int i;
	int j;
	double area;
	area = area_triangle(vertices);
	for (i = 0; i < 3; i++) {
		j = (3 * bv[i]);
		Ce[j] = (Ce[j] + ((((prop -> cs) * (prop -> den)) * area) / 3.0));
		Ce[j + 1] = (Ce[j + 1] + ((((prop -> cs) * (prop -> den)) * area) / 3.0));
		Ce[j + 2] = (Ce[j + 2] + ((((prop -> cp) * (prop -> den)) * area) / 3.0));
	}
}
/* --------------------------------------------------------------------------*/
/* --------------------------------------------------------------------------*/
/* Excitation (ramp function)                                                */

double phi0(t,bound)
     double t;
     double bound;
{
	double value;
	if (t <= bound) {
		value = (0.5 / 3.141592653589793238 * (((2.0 * 3.141592653589793238 * t) / bound) - sin(((2.0 * 3.141592653589793238 * t) / bound))));
		return value;
	}
	else 
		return 1.0;
}
/* --------------------------------------------------------------------------*/
/* --------------------------------------------------------------------------*/
/* First derivative of the excitation (velocity of ramp function)            */

double phi1(t,bound)
     double t;
     double bound;
{
	double value;
	if (t <= bound) {
		value = ((1.0 - cos(((2.0 * 3.141592653589793238 * t) / bound))) / bound);
		return value;
	}
	else 
		return 0.0;
}
/* --------------------------------------------------------------------------*/
/* --------------------------------------------------------------------------*/
/* Second derivative of the excitation (acceleration of ramp function)       */

double phi2(t,bound)
     double t;
     double bound;
{
	double value;
	if (t <= bound) {
		value = (((2.0 * 3.141592653589793238 / bound) / bound) * sin(((2.0 * 3.141592653589793238 * t) / bound)));
		return value;
	}
	else 
		return 0.0;
}
/* --------------------------------------------------------------------------*/
/* --------------------------------------------------------------------------*/
/* Calculate the slip motion at the source node                              */

void slip(u,v,w)
     double *u;
     double *v;
     double *w;
{
	*u = ( *v = ( *w = 0.0));
	*u = ((cos(Src.rake) * sin(Src.strike)) - ((sin(Src.rake) * cos(Src.strike)) * cos(Src.dip)));
	*v = ((cos(Src.rake) * cos(Src.strike)) + ((sin(Src.rake) * sin(Src.strike)) * cos(Src.dip)));
	*w = (sin(Src.rake) * sin(Src.dip));
}
/* --------------------------------------------------------------------------*/
/* --------------------------------------------------------------------------*/
/* Calculate the distance between two points p1 and p2                       */

double distance(p1,p2)
     double *p1;
     double *p2;
{
	return (((p1[0] - p2[0]) * (p1[0] - p2[0])) + ((p1[1] - p2[1]) * (p1[1] - p2[1]))) + ((p1[2] - p2[2]) * (p1[2] - p2[2]));
}
/* --------------------------------------------------------------------------*/
/* --------------------------------------------------------------------------*/
/* Calculate the centroid of a tetrahedron                                   */

void centroid(x,xc)
     double (*x)[3UL];
     double *xc;
{
	int i;
	{
		for (i = 0; i < 3; i++) 
			xc[i] = ((((x[0][i] + x[1][i]) + x[2][i]) + x[3][i]) / 4.0);
	}
}
/* --------------------------------------------------------------------------*/
/* --------------------------------------------------------------------------*/
/* Calculate the distance to the fault from a given point x                 */

double point2fault(x)
     double *x;
{
	double nx;
	double ny;
	double nz;
	double d0;
	nx = (cos(Src.strike) * sin(Src.dip));
	ny = (-sin(Src.strike) * sin(Src.dip));
	nz = cos(Src.dip);
	d0 = -(((nx * Src.xyz[0]) + (ny * Src.xyz[1])) + (nz * Src.xyz[2]));
	return (((((double )nx) * x[0]) + (ny * x[1])) + (nz * x[2])) + d0;
}
/* --------------------------------------------------------------------------*/
/* --------------------------------------------------------------------------*/
/* Matrix (12x12) times vector (12x1) product                                */

void mv12x12(m,v)
     double (*m)[12UL];
     double *v;
{
	int i;
	int j;
	double u[12UL];
	{
		for (i = 0; i < 12; i++) {
			u[i] = 0;
			for (j = 0; j < 12; j++) 
				u[i] += (m[i][j] * v[j]);
		}
		for (i = 0; i < 12; i++) 
			v[i] = u[i];
	}
}
/* --------------------------------------------------------------------------*/
/* --------------------------------------------------------------------------*/
/* Vector (12x1) times vector (12x1) product                                 */

void vv12x12(v1,v2,u)
     double *v1;
     double *v2;
     double *u;
{
	int i;
	{
		for (i = 0; i < 12; i++) 
			u[i] = (v1[i] * v2[i]);
	}
}
/*--------------------------------------------------------------------------*/
/* Graceful exit                                                            */

void arch_bail()
{
	exit(0);
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/

void arch_info()
{
	printf("\n");
	printf("You are running an Archimedes finite element simulation called %s.\n\n",progname);
	printf("The command syntax is:\n\n");
	printf("%s [-Qh] < packfile\n\n",progname);
	printf("Command line options:\n\n");
	printf("    -Q  Quietly suppress all explanation of what this program is doing\n");
	printf("        unless an error occurs.\n");
	printf("    -h  Print this message and exit.\n");
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/*
 * arch_parsecommandline - parse the command line
 */

void arch_parsecommandline(int argc,char **argv,struct options *op)
{
	int i;
	int j;
	/* first set up the defaults */
	op -> quiet = 0;
	op -> help = 0;
	/* now see if the user wants to change any of these */
	for (i = 1; i < argc; i++) {
		if (argv[i][0] == '-') {
			for (j = 1; argv[i][j] != 0; j++) {
				if (argv[i][j] == 'Q') {
					op -> quiet = 1;
				}
				if ((argv[i][j] == 'h') || (argv[i][j] == 72)) {
					op -> help = 1;
				}
			}
		}
	}
	if ((op -> help) != 0) {
		arch_info();
		exit(0);
	}
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/*
 * arch_readnodevector - read a vector of nodal data from the pack file
 *                       called by READNODEVECTOR.stub               
 */

void arch_readnodevector(double *v,int n)
{
	int i;
	int type;
	int attributes;
	fscanf(packfile,"%d %d\n",&type,&attributes);
	if (type != 2) {
		fprintf(stderr,"READNODEVECTOR: unexpected data type\n");
		arch_bail();
	}
	if (attributes != 1) {
		fprintf(stderr,"READNODEVECTOR: unexpected number of attributes\n");
		arch_bail();
	}
	for (i = 0; i < n; i++) {
		fscanf(packfile,"%lf",(v + i));
	}
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/*
 * arch_readelemvector - read a vector of element data from the pack file
 *                       called by READELEMVECTOR.stub               
 */

void arch_readelemvector(double *v,int n)
{
	int i;
	int type;
	int attributes;
	fscanf(packfile,"%d %d\n",&type,&attributes);
	if (type != 1) {
		fprintf(stderr,"READELEMVECTOR: unexpected data type\n");
		arch_bail();
	}
	if (attributes != 1) {
		fprintf(stderr,"READELEMVECTOR: unexpected number of attributes\n");
		arch_bail();
	}
	for (i = 0; i < n; i++) {
		fscanf(packfile,"%lf",(v + i));
	}
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/*
 * arch_readdouble - read a floating point number from the pack file
 */

void arch_readdouble(double *v)
{
	int type;
	int attributes;
	fscanf(packfile,"%d %d\n",&type,&attributes);
	if (type != 3) {
		fprintf(stderr,"READDOUBLE: unexpected data type\n");
		arch_bail();
	}
	if (attributes != 1) {
		fprintf(stderr,"READDOUBLE: unexpected number of attributes\n");
		arch_bail();
	}
	fscanf(packfile,"%lf",(v + 0));
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/

void readpackfile(FILE *packfile,struct options *op)
{
	int oldrow;
	int newrow;
	int i;
	int j;
	int temp1;
	int temp2;
	fscanf(packfile,"%d",&ARCHglobalnodes);
	fscanf(packfile,"%d",&ARCHmesh_dim);
	fscanf(packfile,"%d",&ARCHglobalelems);
	fscanf(packfile,"%d",&ARCHcorners);
	fscanf(packfile,"%d",&ARCHsubdomains);
	fscanf(packfile,"%lf",&ARCHduration);
	/* only one subdomain allowed */
	if (ARCHsubdomains != 1) {
		fprintf(stderr,"%s: too many subdomains(%d), rerun slice using -s1\n",progname,ARCHsubdomains);
		arch_bail();
	}
	/* read nodes */
	if (!((op -> quiet) != 0)) {
		fprintf(stderr,"%s: Reading nodes.\n",progname);
	}
	fscanf(packfile,"%d %d %d",&ARCHnodes,&ARCHmine,&ARCHpriv);
	ARCHglobalnode = ((int *)(malloc((ARCHnodes * sizeof(int )))));
	if (ARCHglobalnode == ((int *)((int *)((void *)0)))) {
		fprintf(stderr,"malloc failed for ARCHglobalnode\n");
		fflush(stderr);
		exit(0);
	}
	ARCHcoord = ((double **)(malloc((ARCHnodes * sizeof(double *)))));
	for (i = 0; i < ARCHnodes; i++) 
		ARCHcoord[i] = ((double *)(malloc((3 * sizeof(double )))));
	for (i = 0; i < ARCHnodes; i++) {
		fscanf(packfile,"%d",(ARCHglobalnode + i));
		for (j = 0; j < ARCHmesh_dim; j++) {
			fscanf(packfile,"%lf",(ARCHcoord[i] + j));
		}
	}
	/* read elements */
	if (!((op -> quiet) != 0)) 
		fprintf(stderr,"%s: Reading elements.\n",progname);
	fscanf(packfile,"%d",&ARCHelems);
	ARCHglobalelem = ((int *)(malloc((ARCHelems * sizeof(int )))));
	if (ARCHglobalelem == ((int *)((int *)((void *)0)))) {
		fprintf(stderr,"malloc failed for ARCHglobalelem\n");
		fflush(stderr);
		exit(0);
	}
	ARCHvertex = ((int **)(malloc((ARCHelems * sizeof(int *)))));
	for (i = 0; i < ARCHelems; i++) 
		ARCHvertex[i] = ((int *)(malloc((4 * sizeof(int )))));
	for (i = 0; i < ARCHelems; i++) {
		fscanf(packfile,"%d",(ARCHglobalelem + i));
		for (j = 0; j < ARCHcorners; j++) {
			fscanf(packfile,"%d",(ARCHvertex[i] + j));
		}
	}
	/* read sparse matrix structure and convert from tuples to CSR */
	if (!((op -> quiet) != 0)) 
		fprintf(stderr,"%s: Reading sparse matrix structure.\n",progname);
	fscanf(packfile,"%d %d",&ARCHmatrixlen,&ARCHcholeskylen);
	ARCHmatrixcol = ((int *)(malloc(((ARCHmatrixlen + 1) * sizeof(int )))));
	if (ARCHmatrixcol == ((int *)((int *)((void *)0)))) {
		fprintf(stderr,"malloc failed for ARCHmatrixcol\n");
		fflush(stderr);
		exit(0);
	}
	ARCHmatrixindex = ((int *)(malloc(((ARCHnodes + 1) * sizeof(int )))));
	if (ARCHmatrixindex == ((int *)((int *)((void *)0)))) {
		fprintf(stderr,"malloc failed for ARCHmatrixindex\n");
		fflush(stderr);
		exit(0);
	}
	{
		oldrow = -1;
	}
	for (i = 0; i < ARCHmatrixlen; i++) {
		fscanf(packfile,"%d",&newrow);
		fscanf(packfile,"%d",(ARCHmatrixcol + i));
		while(oldrow < newrow){
			if ((oldrow + 1) >= (ARCHnodes + 1)) {
				printf("%s: error: (1)idx buffer too small (%d >= %d)\n",progname,(oldrow + 1),(ARCHnodes + 1));
				arch_bail();
			}
			ARCHmatrixindex[++oldrow] = i;
		}
	}
	while(oldrow < ARCHnodes){
		ARCHmatrixindex[++oldrow] = ARCHmatrixlen;
	}
	/* read comm info (which nodes are shared between subdomains) */
	fscanf(packfile,"%d %d",&temp1,&temp2);
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/* 
 * arch_init - initialize the Archimedes simulation 
 *             called by ARCHIMEDES_INIT.stub
 */

void arch_init(int argc,char **argv,struct options *op)
{
	/* parse the command line options */
	progname = argv[0];
	arch_parsecommandline(argc,argv,op);
	/* read the pack file */
	packfile = fopen(argv[1],"r");
	readpackfile(packfile,op);
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/* Matrix vector product - basic version                                    */

void smvp(int nodes,double ***A,int *Acol,int *Aindex,double **v,double **w)
{
	int i;
	int Anext;
	int Alast;
	int col;
	double sum0;
	double sum1;
	double sum2;
	for (i = 0; i < nodes; i++) {
		Anext = Aindex[i];
		Alast = Aindex[i + 1];
		sum0 = (((A[Anext][0][0] * v[i][0]) + (A[Anext][0][1] * v[i][1])) + (A[Anext][0][2] * v[i][2]));
		sum1 = (((A[Anext][1][0] * v[i][0]) + (A[Anext][1][1] * v[i][1])) + (A[Anext][1][2] * v[i][2]));
		sum2 = (((A[Anext][2][0] * v[i][0]) + (A[Anext][2][1] * v[i][1])) + (A[Anext][2][2] * v[i][2]));
		Anext++;
		while(Anext < Alast){
			col = Acol[Anext];
			sum0 += (((A[Anext][0][0] * v[col][0]) + (A[Anext][0][1] * v[col][1])) + (A[Anext][0][2] * v[col][2]));
			sum1 += (((A[Anext][1][0] * v[col][0]) + (A[Anext][1][1] * v[col][1])) + (A[Anext][1][2] * v[col][2]));
			sum2 += (((A[Anext][2][0] * v[col][0]) + (A[Anext][2][1] * v[col][1])) + (A[Anext][2][2] * v[col][2]));
			w[col][0] += (((A[Anext][0][0] * v[i][0]) + (A[Anext][1][0] * v[i][1])) + (A[Anext][2][0] * v[i][2]));
			w[col][1] += (((A[Anext][0][1] * v[i][0]) + (A[Anext][1][1] * v[i][1])) + (A[Anext][2][1] * v[i][2]));
			w[col][2] += (((A[Anext][0][2] * v[i][0]) + (A[Anext][1][2] * v[i][1])) + (A[Anext][2][2] * v[i][2]));
			Anext++;
		}
		w[i][0] += sum0;
		w[i][1] += sum1;
		w[i][2] += sum2;
	}
}
/*--------------------------------------------------------------------------*/
/* Matrix vector product - hand optimized with lots of temporaries          */

void smvp_opt(nodes,A,Acol,Aindex,v,w)
     int nodes;
     double ***A;
     int *Acol;
     int *Aindex;
     double **v;
     double **w;
{
	int i;
	int Anext;
	int Alast;
	double vi0;
	double vi1;
	double vi2;
	double sum0;
	double sum1;
	double sum2;
	double value;
	double vcol0;
	double vcol1;
	double vcol2;
	double wcol0;
	double wcol1;
	double wcol2;
	int col;
	{
		for (i = 0; i < nodes; i++) {
			w[i][0] = 0.0;
			w[i][1] = 0.0;
			w[i][2] = 0.0;
		}
	}
	for (i = 0; i < nodes; i++) {
		vi0 = v[i][0];
		vi1 = v[i][1];
		vi2 = v[i][2];
		Anext = Aindex[i];
		Alast = Aindex[i + 1];
		sum0 = (((w[i][0] + (A[Anext][0][0] * vi0)) + (A[Anext][0][1] * vi1)) + (A[Anext][0][2] * vi2));
		sum1 = (((w[i][1] + (A[Anext][1][0] * vi0)) + (A[Anext][1][1] * vi1)) + (A[Anext][1][2] * vi2));
		sum2 = (((w[i][2] + (A[Anext][2][0] * vi0)) + (A[Anext][2][1] * vi1)) + (A[Anext][2][2] * vi2));
		Anext++;
		while(Anext < Alast){
			col = Acol[Anext];
			vcol0 = v[col][0];
			vcol1 = v[col][1];
			vcol2 = v[col][2];
			value = A[Anext][0][0];
			sum0 += (value * vcol0);
			wcol0 = (w[col][0] + (value * vi0));
			value = A[Anext][0][1];
			sum0 += (value * vcol1);
			wcol1 = (w[col][1] + (value * vi0));
			value = A[Anext][0][2];
			sum0 += (value * vcol2);
			wcol2 = (w[col][2] + (value * vi0));
			value = A[Anext][1][0];
			sum1 += (value * vcol0);
			wcol0 += (value * vi1);
			value = A[Anext][1][1];
			sum1 += (value * vcol1);
			wcol1 += (value * vi1);
			value = A[Anext][1][2];
			sum1 += (value * vcol2);
			wcol2 += (value * vi1);
			value = A[Anext][2][0];
			sum2 += (value * vcol0);
			w[col][0] = (wcol0 + (value * vi2));
			value = A[Anext][2][1];
			sum2 += (value * vcol1);
			w[col][1] = (wcol1 + (value * vi2));
			value = A[Anext][2][2];
			sum2 += (value * vcol2);
			w[col][2] = (wcol2 + (value * vi2));
			Anext++;
		}
		w[i][0] = sum0;
		w[i][1] = sum1;
		w[i][2] = sum2;
	}
}
/*--------------------------------------------------------------------------*/
/* Dynamic memory allocations and initializations                           */

void mem_init()
{
	int i;
	int j;
	int k;
	/* Node vector */
	nodekindf = ((double *)(malloc((ARCHnodes * sizeof(double )))));
	if (nodekindf == ((double *)((double *)((void *)0)))) {
		fprintf(stderr,"malloc failed for nodekindf\n");
		fflush(stderr);
		exit(0);
	}
	/* Node vector */
	nodekind = ((int *)(malloc((ARCHnodes * sizeof(int )))));
	if (nodekind == ((int *)((int *)((void *)0)))) {
		fprintf(stderr,"malloc failed for nodekind\n");
		fflush(stderr);
		exit(0);
	}
	/* Element vector */
	source_elms = ((int *)(malloc((ARCHelems * sizeof(int )))));
	if (source_elms == ((int *)((int *)((void *)0)))) {
		fprintf(stderr,"malloc failed for source_elms\n");
		fflush(stderr);
		exit(0);
	}
	/* Velocity array */
	double *vel_temp = (double *)(malloc(((ARCHnodes * 3) * sizeof(double ))));
	vel = ((double **)(malloc((ARCHnodes * sizeof(double *)))));
	if (vel == ((double **)((double **)((void *)0)))) {
		fprintf(stderr,"malloc failed for vel\n");
		fflush(stderr);
		exit(0);
	}
	for (i = 0; i < ARCHnodes; i++) {
		vel[i] = (vel_temp + (i * 3));
		if (vel[i] == ((double *)((double *)((void *)0)))) {
			fprintf(stderr,"malloc failed for vel[%d]\n",i);
			fflush(stderr);
			exit(0);
		}
	}
	/* Mass matrix */
	double *M_temp = (double *)(malloc(((ARCHnodes * 3) * sizeof(double ))));
	M = ((double **)(malloc((ARCHnodes * sizeof(double *)))));
	if (M == ((double **)((double **)((void *)0)))) {
		fprintf(stderr,"malloc failed for M\n");
		fflush(stderr);
		exit(0);
	}
	for (i = 0; i < ARCHnodes; i++) {
		M[i] = (M_temp + (i * 3));
		if (M[i] == ((double *)((double *)((void *)0)))) {
			fprintf(stderr,"malloc failed for M[%d]\n",i);
			fflush(stderr);
			exit(0);
		}
	}
	/* Damping matrix */
	double *C_temp = (double *)(malloc(((ARCHnodes * 3) * sizeof(double ))));
	C = ((double **)(malloc((ARCHnodes * sizeof(double *)))));
	if (C == ((double **)((double **)((void *)0)))) {
		fprintf(stderr,"malloc failed for C\n");
		fflush(stderr);
		exit(0);
	}
	for (i = 0; i < ARCHnodes; i++) {
		//(double *) malloc(3 * sizeof(double));
		C[i] = (C_temp + (i * 3));
		if (C[i] == ((double *)((double *)((void *)0)))) {
			fprintf(stderr,"malloc failed for C[%d]\n",i);
			fflush(stderr);
			exit(0);
		}
	}
	/* Auxiliary mass matrix */
	double *M23_temp = (double *)(malloc(((ARCHnodes * 3) * sizeof(double ))));
	M23 = ((double **)(malloc((ARCHnodes * sizeof(double *)))));
	if (M23 == ((double **)((double **)((void *)0)))) {
		fprintf(stderr,"malloc failed for M23\n");
		fflush(stderr);
		exit(0);
	}
	for (i = 0; i < ARCHnodes; i++) {
		M23[i] = (M23_temp + (i * 3));
		if (M23[i] == ((double *)((double *)((void *)0)))) {
			fprintf(stderr,"malloc failed for M23[%d]\n",i);
			fflush(stderr);
			exit(0);
		}
	}
	/* Auxiliary damping matrix */
	double *C23_temp = (double *)(malloc(((ARCHnodes * 3) * sizeof(double ))));
	C23 = ((double **)(malloc((ARCHnodes * sizeof(double *)))));
	if (C23 == ((double **)((double **)((void *)0)))) {
		fprintf(stderr,"malloc failed for C23\n");
		fflush(stderr);
		exit(0);
	}
	for (i = 0; i < ARCHnodes; i++) {
		C23[i] = (C23_temp + (i * 3));
		if (C23[i] == ((double *)((double *)((void *)0)))) {
			fprintf(stderr,"malloc failed for C23[%d]\n",i);
			fflush(stderr);
			exit(0);
		}
	}
	/* Auxiliary vector */
	double *V23_temp = (double *)(malloc(((ARCHnodes * 3) * sizeof(double ))));
	V23 = ((double **)(malloc((ARCHnodes * sizeof(double *)))));
	if (V23 == ((double **)((double **)((void *)0)))) {
		fprintf(stderr,"malloc failed for V23\n");
		fflush(stderr);
		exit(0);
	}
	for (i = 0; i < ARCHnodes; i++) {
		V23[i] = (V23_temp + (i * 3));
		if (V23[i] == ((double *)((double *)((void *)0)))) {
			fprintf(stderr,"malloc failed for V23[%d]\n",i);
			fflush(stderr);
			exit(0);
		}
	}
	double *disp0_temp = (double *)(malloc(((ARCHnodes * 3) * sizeof(double ))));
	disp0 = ((double **)(malloc((ARCHnodes * sizeof(double *)))));
	if (disp0 == ((double **)((double **)((void *)0)))) {
		fprintf(stderr,"malloc failed for disp0\n");
		fflush(stderr);
		exit(0);
	}
	for (j = 0; j < ARCHnodes; j++) {
		disp0[j] = (disp0_temp + (j * 3));
		if (disp0[j] == ((double *)((double *)((void *)0)))) {
			fprintf(stderr,"malloc failed for disp0[%d]\n",j);
			fflush(stderr);
			exit(0);
		}
	}
	double *disp1_temp = (double *)(malloc(((ARCHnodes * 3) * sizeof(double ))));
	disp1 = ((double **)(malloc((ARCHnodes * sizeof(double *)))));
	if (disp1 == ((double **)((double **)((void *)0)))) {
		fprintf(stderr,"malloc failed for disp1\n");
		fflush(stderr);
		exit(0);
	}
	for (j = 0; j < ARCHnodes; j++) {
		disp1[j] = (disp1_temp + (j * 3));
		if (disp1[j] == ((double *)((double *)((void *)0)))) {
			fprintf(stderr,"malloc failed for disp1[%d]\n",j);
			fflush(stderr);
			exit(0);
		}
	}
	double *disp2_temp = (double *)(malloc((sizeof(double ) * 3 * ARCHnodes)));
	disp2 = ((double **)(malloc((ARCHnodes * sizeof(double *)))));
	if (disp2 == ((double **)((double **)((void *)0)))) {
		fprintf(stderr,"malloc failed for disp2\n");
		fflush(stderr);
		exit(0);
	}
	for (j = 0; j < ARCHnodes; j++) {
		disp2[j] = (disp2_temp + (j * 3));
		if (disp2[j] == ((double *)((double *)((void *)0)))) {
			fprintf(stderr,"malloc failed for disp2[%d]\n",j);
			fflush(stderr);
			exit(0);
		}
	}
	/* Stiffness matrix K[ARCHmatrixlen][3][3] */
	double *K_temp = (double *)(malloc((sizeof(double ) * 9 * ARCHmatrixlen)));
	K = ((double **)(malloc((ARCHmatrixlen * sizeof(double **)))));
	if (K == ((double **)((double **)((void *)0)))) {
		fprintf(stderr,"malloc failed for K\n");
		fflush(stderr);
		exit(0);
	}
	for (i = 0; i < ARCHmatrixlen; i++) {
		K[i] = (K_temp + (i * 9));
		if (K[i] == ((double *)((double *)((void *)0)))) {
			fprintf(stderr,"malloc failed for K[%d]\n",i);
			fflush(stderr);
			exit(0);
		}
	}
	{
		/* Initializations */
		for (i = 0; i < ARCHnodes; i++) {
			nodekind[i] = 0;
			for (j = 0; j < 3; j++) {
				M[i][j] = 0.0;
				C[i][j] = 0.0;
				M23[i][j] = 0.0;
				C23[i][j] = 0.0;
				V23[i][j] = 0.0;
				disp0[i][j] = 0.0;
				disp1[i][j] = 0.0;
				disp2[i][j] = 0.0;
			}
		}
		for (i = 0; i < ARCHelems; i++) {
			source_elms[i] = 1;
		}
		for (i = 0; i < ARCHmatrixlen; i++) {
			for (j = 0; j < 3; j++) {
				for (k = 0; k < 3; k++) {
					K[i][(j * 3) + k] = 0.0;
				}
			}
		}
	}
}
/*--------------------------------------------------------------------------*/
